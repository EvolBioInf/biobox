#+begin_export latex
\section*{Introduction}
The coalescent describes the evolutionary history of a sample of $n$
lineages in a population of $N$ individuals~\cite{hud90:gen}. It is a
binary tree with exponentially distributed branch lengths. The
topology of this tree is generated by taking a slice of $2n-1$ nodes,
Figure~\ref{fig:nodes} illustrates this for $n=4$. The first 4 nodes
are leaves in green, the remaining 3 are internal nodes, the last of
which is the root in brown. Tree construction is done by taking the
first internal node, 5 in our example, and picking two children from
the possible four. In the next round, node 5 is itself among the
potential children, and so on, until the root has been
assigned. Algorithm~\ref{alg:coa} summarizes the steps for this
construction of random binary trees.

\begin{figure}[h]
\begin{center}
\begin{tabular}{lccccccc}
\hline
Index & 1 & 2 & 3 & 4 & 5 & 6 & 7\\\hline
Node & \textcolor{green}{1} & \textcolor{green}{2} & \textcolor{green}{3} & \textcolor{green}{4} & 5 & 6 & \textcolor{brown}{7}\\\hline
\end{tabular}
\end{center}
\caption{A slice of seven nodes to construct a coalescent for sample
  size $n=4$; leaf nodes are in green, internal nodes in black, and the
  root in brown.}\label{fig:nodes}
\end{figure}

\begin{algorithm}[h]
  \caption{Algorithm for generating random trees used in constructing
    the coalescent.}\label{alg:coa}
  \input{../pickChildren/algCoalTree}
\end{algorithm}

\begin{figure}[h]
  \begin{center}
    \begin{tabular}{cc}
      \textbf{A} & \textbf{B}\\
      \raisebox{1cm}{
        \begin{tabular}{lllllllllllll}
	\hline
	$p$  & $c_1$ & $c_2$ &&& $t_1$ & $t_2$ & $t_3$ & $t_4$ && $t_5$ & $t_6$ & $t_7$\\\hline
	5    &  3    &  3    &&&   1   & 2     & 5     & -     && - &   6 &    7\\
        6    &  2    &  1    &&&   6   & 5     & -     & -     && - &   - &    7\\
        7    &  1    &  1    &&&   7   & -     & -     & -     && - &   - &    -\\
	\hline
        \end{tabular}
      }
      &
      \raisebox{0.2cm}{\includegraphics{../pickChildren/top}}
    \end{tabular}
  \end{center}
  \caption{Example output from \ty{pickChildren}, where parent nodes,
    $p$ have children at positions $c_1$ and $c_2$ in the tree array,
    $t_i$, shown on the right, after the children were picked
    (\textbf{A}); the tree topology after all children have been
    picked (\textbf{B}).}\label{fig:chi}
\end{figure}

The program \ty{pickChildren} demonstrates Algorithm~\ref{alg:coa}. It
takes as input the sample size, $n$, and returns a table like the one
shown in Figure~\ref{fig:chi}A, where each parent, $p$, has two
children, $c_1$ and $c_2$, the values of which refer to their
positions in the slice of nodes shown as $t_i$
(Figure~\ref{fig:nodes}). The tree constructed at the end of
Algorithm~\ref{alg:coa} can be written in Newick format to file and
then plotted using \ty{plotTree} to give Figure~\ref{fig:chi}B.

\section*{Implementation}
Our outline of \ty{pickChildren} has hooks for imports, types,
functions, and the logic of the main function.
#+end_export
#+begin_src go <<pickChildren.go>>=
  package main

  import (
	  //<<Imports, Ch. \ref{ch:pc}>>
  )

  //<<Types, Ch. \ref{ch:pc}>>
  //<<Functions, Ch. \ref{ch:pc}>>
  func main() {
	  //<<Main function, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
In the main function we prepare the \ty{log} package for errors from
\ty{pickChildren}, set the usage, declare the options, parse them, and
pick the children.
#+end_export
#+begin_src go <<Main function, Ch. \ref{ch:pc}>>=
  util.PrepLog("pickChildren")
  //<<Set usage, Ch. \ref{ch:pc}>>
  //<<Declare options, Ch. \ref{ch:pc}>>
  //<<Parse options, Ch. \ref{ch:pc}>>
  //<<Pick children, Ch. \ref{ch:pc}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{pickChildren}, and an example command.
#+end_export
#+begin_src go <<Set usage, Ch. \ref{ch:pc}>>=
  u := "pickChildren [-h] [option]"
  p := "Demo the construction of a coalescent topology."
  e := "pickChildren -n 5 -t pc.nwk"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
Apart from the obligatory version option, we declare an option for
setting the sample size, \ty{-n}, an option for printing the
underlying tree to file, \ty{-t}, and an option for setting the seed
for the random number generator, \ty{-s}.
#+end_export
#+begin_src go <<Declare options, Ch. \ref{ch:pc}>>=
  optV := flag.Bool("v", false, "version")
  optN := flag.Int("n", 4, "sample size")
  optT := flag.String("t", "", "print tree to file")
  optS := flag.Int("s", 0, "seed for random number generator")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "flag"
#+end_src
#+begin_export latex
We parse the options and respond to \ty{-v} first, as a request for
the version stops the program. Then we respond to \ty{-n} and \ty{-s}.
#+end_export
#+begin_src go <<Parse options, Ch. \ref{ch:pc}>>=
  flag.Parse()
  //<<Respond to \ty{-v}, Ch. \ref{ch:pc}>>
  //<<Respond to \ty{-n}, Ch. \ref{ch:pc}>>
  //<<Respond to \ty{-s}, Ch. \ref{ch:pc}>>
#+end_src
#+begin_export latex
If the user requested the version, we print the information for
\ty{pickChildren}, which includes the version.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Ch. \ref{ch:pc}>>=
  if *optV {
	  util.PrintInfo("pickChildren")
  }
#+end_src
#+begin_export latex
If the user entered a sample size less than 2, we bail with a friendly
message.
#+end_export
#+begin_src go <<Respond to \ty{-n}, Ch. \ref{ch:pc}>>=
  n := *optN
  if n <= 2 {
	  log.Fatal("please use a sample size " +
		  "of at least 2")
  }
#+end_src
#+begin_export latex
We import \ty{log}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "log"
#+end_src
#+begin_export latex
If the user picked a seed for the random number generator, we set
that. Otherwise, we seed the random number generator with the current
time.
#+end_export
#+begin_src go <<Respond to \ty{-s}, Ch. \ref{ch:pc}>>=
  seed := int64(*optS)
  if seed == 0 {
	  seed = time.Now().UnixNano()
  }
  ran := rand.New(rand.NewSource(seed))
#+end_src
#+begin_export latex
We import \ty{time} and \ty{rand}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "time"
  "math/rand"
#+end_src
#+begin_export latex
We construct a tree, which consists of nodes. So we declare a node
consisting of an identifier and two children.
#+end_export
#+begin_src go <<Types, Ch. \ref{ch:pc}>>=
  type Node struct {
	  id int
	  child1, child2 *Node
  }
#+end_src
#+begin_export latex
When picking children, we generate a table of parents, their children,
and the tree array as shown in Figure~\ref{fig:chi}A. We begin
printing this table by generating a tab writer, which we use to first
print the header. To print the rest of the table, we construct the
tree and iterate over its internal nodes, as these are the nodes that
require child nodes. At the end we flush the tab writer. If the user
opted for tree printing, we set node times before we print the tree.
#+end_export
#+begin_src go <<Pick children, Ch. \ref{ch:pc}>>=
  w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
  //<<Print header, Ch. \ref{ch:pc}>>
  //<<Construct tree, Ch. \ref{ch:pc}>>
  //<<Iterate over internal nodes, Ch. \ref{ch:pc}>>
  w.Flush()
  if *optT != "" {
	  //<<Set node times, Ch. \ref{ch:pc}>>
	  //<<Print tree, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
We import \ty{nwk}, \ty{tabwriter}, \ty{os}, and \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "github.com/evolbioinf/nwk"
  "text/tabwriter"
  "os"
  "fmt"
#+end_src
#+begin_export latex
We print the table header with $2n-1$ slots for the tree array. We
separate the tree array by two extra spaces, and the internal nodes
from the leaves by one extra space.
#+end_export
#+begin_src go <<Print header, Ch. \ref{ch:pc}>>=
  fmt.Fprintf(w, "# p\tc_1\tc_2\t\t")
  for i := 0; i < n; i++ {
	  fmt.Fprintf(w, "\tt_%d", i+1)
  }
  fmt.Fprintf(w, "\t")
  for i := n; i < 2*n-1; i++ {
	  fmt.Fprintf(w, "\tt_%d", i+1)
  }
  fmt.Fprintf(w, "\n")
#+end_src
#+begin_export latex
We construct the tree as a slice of nodes as illustrated in
Figure~\ref{fig:nodes}. Their identifiers are identical to their
index. We think of the leafy part of the tree as the ``kindergarten'',
as this is where we get the children of the internal, or parent,
nodes. Like parents picking up their children from kindergarten. The
last entry in the tree slice is the root of the tree, which we store
separately to make it easy to print the tree later on.
#+end_export
#+begin_src go <<Construct tree, Ch. \ref{ch:pc}>>=
  tree := make([]*nwk.Node, 2 * n - 1)
  for i := 0; i < 2 * n - 1; i++ {
	  v := new(nwk.Node)
	  v.Id = i
	  v.Label = strconv.Itoa(i+1)
	  tree[i] = v
  }
  root := tree[2*n-2]
#+end_src
#+begin_export latex
We import \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "strconv"
#+end_src
#+begin_export latex
We iterate over the parents (lines 1 and 2 of
Algorithm~\ref{alg:coa}), print them, and for each one pick its first
and its second child. Then we print the tree array.
#+end_export
#+begin_src go <<Iterate over internal nodes, Ch. \ref{ch:pc}>>=
  for i := n; i >= 2; i-- {
	  p := 2 * n - i
	  fmt.Fprintf(w, "%d", p + 1)
	  //<<Pick first child, Ch. \ref{ch:pc}>>
	  //<<Pick second child, Ch. \ref{ch:pc}>>
	  //<<Print tree array, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
We pick the first child according to lines 3 and 4 of
Algorithm~\ref{alg:coa} and print it. Then we replace the child by the
leftmost entry in the kindergarten, $t_i$ (line 5). In case the tree
is to be printed later on, we set the child's parent link. To
facilitate tracing of the node movements in the tree array, we set the
old position of $t_i$ to nil.
#+end_export
#+begin_src go <<Pick first child, Ch. \ref{ch:pc}>>=
  c := int(float64(i) * ran.Float64())
  tree[p].AddChild(tree[c])
  fmt.Fprintf(w, "\t%d", c+1)
  tree[c] = tree[i-1]
  tree[c].Parent = tree[p]
  tree[i-1] = nil
#+end_src
#+begin_export latex
We pick the second child according to lines 6 and 7 of
Algorithm~\ref{alg:coa} and print it. Then we replace the child by its
parent, which thus enters the kindergarten. Again, we also set the
child's parent link and mark that $t_p$ is now elsewhere by setting
its old position to nil.
#+end_export
#+begin_src go <<Pick second child, Ch. \ref{ch:pc}>>=
  c = int(float64(i-1) * ran.Float64())
  tree[p].AddChild(tree[c])
  fmt.Fprintf(w, "\t%d\t\t", c+1)
  tree[c] = tree[p]
  tree[c].Parent = tree[p]
  tree[p] = nil
#+end_src
#+begin_export latex
The final element of our output for the current internal node is the
tree array. We print the kindergarten, followed by the internal nodes.
#+end_export
#+begin_src go <<Print tree array, Ch. \ref{ch:pc}>>=
  for i := 0; i < n; i++ {
	  //<<Print node ID, Ch. \ref{ch:pc}>>
  }
  fmt.Fprintf(w, "\t")
  for i := n; i < 2*n-1; i++ {
	  //<<Print node ID, Ch. \ref{ch:pc}>>
  }
  fmt.Fprintf(w, "\n")
#+end_src
#+begin_export latex
If the node has moved elsewhere, we print a dash, otherwise we print
its ID.
#+end_export
#+begin_src go <<Print node ID, Ch. \ref{ch:pc}>>=
  if tree[i] == nil {
	  fmt.Fprintf(w, "\t-")
  } else {
	  fmt.Fprintf(w, "\t%d", tree[i].Id + 1)
  }
#+end_src
#+begin_export latex
When printing the tree, its root is identified by its lack of a
parent. So we first ensure that. Then we set its node times such that
all leaves are aligned at the zero line, and the internal nodes have
heights 1, 2, and so on, in the order in which we added them to the
tree. To calculate a node's height, we compare it's ID to the sample
size, so we also pass that to \ty{setTimes}.
#+end_export
#+begin_src go <<Set node times, Ch. \ref{ch:pc}>>=
  root.Parent = nil
  setTimes(root, n)
#+end_src
#+begin_export latex
Inside \ty{setTimes}, we recursively traverses the tree depth first
and calculates the branch length for each node.
#+end_export
#+begin_src go <<Functions, Ch. \ref{ch:pc}>>=
  func setTimes(v *nwk.Node, n int) {
	  if v == nil {
		  return
	  }
	  setTimes(v.Child, n)
	  setTimes(v.Sib, n)
	  //<<Set branch length, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
If the current node has no parent, it is the root, which doesn't have
a branch to parent, so we return. Otherwise, we mark the node as
having a branch length, which we calculate as the difference between
the height of the current node and its parent. Leaves have height
zero, and we said above that the first internal node has height 1, the
second 2, and so on. We calculate the height from the difference
between the node ID and the sample size,
\[
v_{\mathrm{height}} = v_{\mathrm{Id}} - n + 1.
\]
A height of less than zero is set to zero. If a node has no parent, we
are at the root and exit the calculation.
#+end_export
#+begin_src go <<Set branch length, Ch. \ref{ch:pc}>>=
  if v.Parent == nil {
	  return
  }
  v.HasLength = true
  parentHeight := v.Parent.Id - n + 1
  nodeHeight := v.Id - n + 1
  if nodeHeight < 0 {
	  nodeHeight = 0
  }
  v.Length = float64(parentHeight) - float64(nodeHeight)
#+end_src
#+begin_export latex
The tree is now ready to be printed. So we open the tree file, print
the tree, and close the file again.
#+end_export
#+begin_src go <<Print tree, Ch. \ref{ch:pc}>>=
  f, err := os.Create(*optT)
  if err != nil {
	  log.Fatal(err)
  }
  fmt.Fprintf(f, "%s\n", root)
  f.Close()
#+end_src
#+begin_export latex
The program \ty{pickChildren} is finished, so let's test it.

\section*{Testing}
The outline of our test of \ty{pickChildren} has hooks for imports and
the testing logic.
#+end_export
#+begin_src go <<pickChildren_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch. \ref{ch:pc}>>
  )

  func TestPickChildren(t *testing.T) {
	  //<<Testing, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
We construct a set of tests, and run each one of them.
#+end_export
#+begin_src go <<Testing, Ch. \ref{ch:pc}>>=
  tests := make([]*exec.Cmd, 0)
  //<<Construct tests, Ch. \ref{ch:pc}>>
  for i, test := range tests {
	  //<<Run test, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:pc}>>=
  "os/exec"
#+end_src
#+begin_export latex
We run each test with the same seed for the random number generator to
keep the tests stable. Then we construct a test with default sample
size and one with sample size 5 where we also write the tree to
file. In our last test we inspect the tree file.
#+end_export
#+begin_src go <<Construct tests, Ch. \ref{ch:pc}>>=
  s := "1"
  test := exec.Command("./pickChildren", "-s", s)
  tests = append(tests, test)
  test = exec.Command("./pickChildren", "-s", s, "-n", "5",
	  "-t", "test.nwk")
  tests = append(tests, test)
  test = exec.Command("cat", "test.nwk")
  tests = append(tests, test)
#+end_src
#+begin_export latex
When running a test, we compare the result we get with the result we
want, which is stored in files \ty{r1.txt} and \ty{r2.txt}.
#+end_export
#+begin_src go <<Run test, Ch. \ref{ch:pc}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
  file := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := os.ReadFile(file)
  if err != nil {
	  t.Errorf("couldn't open %q", file)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{strconv}, \ty{os}, and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:pc}>>=
  "strconv"
  "os"
  "bytes"
#+end_src
