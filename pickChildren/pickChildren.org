#+begin_export latex
\section*{Introduction}
The coalescent describes the evolutionary history of a sample of $n$
lineages in a population of $N$ individuals~\cite{hud90:gen}. It is a
binary tree with exponentially distributed branch lengths. The
topology of this tree is generated by taking a slice of $2n-1$
nodes. Figure~\ref{fig:nodes} illustrates this for $n=4$. The first 4
nodes are leaves in green, the remaining 3 are internal nodes, the
last of which is the root in brown. Tree construction is done by
taking the first internal node, 5 in our example, and picking two
children from the possible four. In the next round, node 5 is itself
among the nodes serving as children, and so on, until the root has
been assigned. Algorithm~\ref{alg:coa} summarizes the steps for this
construction of random binary trees.

\begin{figure}[hb]
\begin{center}
\begin{tabular}{lccccccc}
\hline
Index & 1 & 2 & 3 & 4 & 5 & 6 & 7\\\hline
Node & \textcolor{green}{1} & \textcolor{green}{2} & \textcolor{green}{3} & \textcolor{green}{4} & 5 & 6 & \textcolor{brown}{7}\\\hline
\end{tabular}
\end{center}
\caption{A slice of seven nodes to construct a coalescent for sample
  size $n=4$; leaf nodes are in green, internal nodes in black, and the
  root in brown.}\label{fig:nodes}
\end{figure}

\begin{algorithm}[hb]
  \caption{Algorithm for generating random trees used in constructing
    the coalescent.}\label{alg:coa}
  \input{../pickChildren/algCoalTree}
\end{algorithm}

\begin{figure}[hb]
  \begin{center}
    \begin{tabular}{cc}
      \textbf{A} & \textbf{B}\\
      \raisebox{1cm}{
        \begin{tabular}{lll}
          \hline
          $p$ & $c_1$ & $c_2$\\\hline
          5 & 1 & 2\\
          6 & 1 & 2\\
          7 & 1 & 1\\\hline
        \end{tabular}
      }
      &
      \scalebox{0.3}{\includegraphics{../pickChildren/top}}
    \end{tabular}
  \end{center}
  \caption{Example output from \ty{pickChildren}, where parent nodes,
    $p$ are associated with child nodes $c_1$ and $c_2$ (\textbf{A}),
    and the corresponding tree topology (\textbf{B}).}\label{fig:chi}
\end{figure}

The program \ty{pickChildren} demonstrates the method for picking the
children of the internal nodes at the heart of
Algorithm~\ref{alg:coa}. It takes as input the sample size, $n$, and
returns a table like the one shown in Figure~\ref{fig:chi}A, where
each parent, $p$, has two children, $c_1$ and $c_2$, the values of
which refer to their positions in the slice of nodes
(Figure~\ref{fig:nodes}). This table can be converted to the
corresponding tree shown in Figure~\ref{fig:chi}B using the program
\ty{drawChildren}.

\section*{Implementation}
Our outline of \ty{pickChildren} has hooks for imports, types, and the
logic of the main function.
#+end_export
#+begin_src go <<pickChildren.go>>=
  package main

  import (
	  //<<Imports, Ch. \ref{ch:pc}>>
  )

  //<<Types, Ch. \ref{ch:pc}>>
  func main() {
	  //<<Main function, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
In the main function we prepare the \ty{log} package for errors from
\ty{pickChildren}, set the usage, declare the options, parse the
options, and pick the children.
#+end_export
#+begin_src go <<Main function, Ch. \ref{ch:pc}>>=
  util.PrepLog("pickChildren")
  //<<Set usage, Ch. \ref{ch:pc}>>
  //<<Declare options, Ch. \ref{ch:pc}>>
  //<<Parse options, Ch. \ref{ch:pc}>>
  //<<Pick children, Ch. \ref{ch:pc}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{pickChildren}, and an example command.
#+end_export
#+begin_src go <<Set usage, Ch. \ref{ch:pc}>>=
  u := "pickChildren [-h] [option]"
  p := "Demo the construction of a coalescent topology."
  e := "pickChildren -n 4 | tee pc.txt | drawChildren |" +
	  "dot -T x11"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
Apart from the obligatory version option, we declare an option for
setting the sample size, \ty{-n}, and an option for setting the seed
for the random number generator, \ty{-s}.
#+end_export
#+begin_src go <<Declare options, Ch. \ref{ch:pc}>>=
  optV := flag.Bool("v", false, "version")
  optN := flag.Int("n", 10, "sample size")
  optS := flag.Int("s", 0, "seed for random number generator")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "flag"
#+end_src
#+begin_export latex
We parse the options and respond to \ty{-v} first, as a request for
the version stops the program. Then we respond to \ty{-n} and \ty{-s}.
#+end_export
#+begin_src go <<Parse options, Ch. \ref{ch:pc}>>=
  flag.Parse()
  //<<Respond to \ty{-v}, Ch. \ref{ch:pc}>>
  //<<Respond to \ty{-n}, Ch. \ref{ch:pc}>>
  //<<Respond to \ty{-s}, Ch. \ref{ch:pc}>>
#+end_src
#+begin_export latex
If the user requested the version, we print the information for
\ty{pickChildren}, which includes the version.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Ch. \ref{ch:pc}>>=
  if *optV {
	  util.PrintInfo("pickChildren")
  }
#+end_src
#+begin_export latex
If the user entered a sample size less than 2, we bail with a friendly
message.
#+end_export
#+begin_src go <<Respond to \ty{-n}, Ch. \ref{ch:pc}>>=
  n := *optN
  if n <= 2 {
	  log.Fatal("please use a sample size " +
		  "of at least 2")
  }
#+end_src
#+begin_export latex
We import \ty{log}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "log"
#+end_src
#+begin_export latex
If the user picked a seed for the random number generator, we set
that. Otherwise, we seed the random number generator with the current
time.
#+end_export
#+begin_src go <<Respond to \ty{-s}, Ch. \ref{ch:pc}>>=
  seed := int64(*optS)
  if seed == 0 {
	  seed = time.Now().UnixNano()
  }
  ran := rand.New(rand.NewSource(seed))
#+end_src
#+begin_export latex
We import \ty{time} and \ty{rand}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "time"
  "math/rand"
#+end_src
#+begin_export latex
We construct a tree, which consists of nodes. So we declare a node
consisting of two children.
#+end_export
#+begin_src go <<Types, Ch. \ref{ch:pc}>>=
  type Node struct {
	  child1, child2 *Node
  }
#+end_src
#+begin_export latex
When picking children, we generate a table of parents and their
children as shown in Figure~\ref{fig:chi}A. We print the header of
this table. Then we construct the tree and iterate over its internal
nodes, as these are the nodes that require child nodes.
#+end_export
#+begin_src go <<Pick children, Ch. \ref{ch:pc}>>=
  fmt.Printf("# p\tc_1\tc_2\n")
  //<<Construct tree, Ch. \ref{ch:pc}>>
  //<<Iterate over internal nodes, Ch. \ref{ch:pc}>>
#+end_src
#+begin_export latex
We import \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:pc}>>=
  "fmt"
#+end_src
#+begin_export latex
We construct the tree as a slice of nodes as illustrated in
Figure~\ref{fig:nodes}. We think of the leafy part of the tree as the
``kindergarten'', as this is where we get the children of the
internal, or parent, nodes. Like parents picking up their children
from kindergarten.
#+end_export
#+begin_src go <<Construct tree, Ch. \ref{ch:pc}>>=
  tree := make([]*Node, 2 * n - 1)
  for i := 0; i < 2 * n -1; i++ {
	  tree[i] = new(Node)
  }
#+end_src
#+begin_export latex
We iterate over the parents (lines 1 and 2 of
Algorithm~\ref{alg:coa}), print them, and for each one pick its first
and its second child.
#+end_export
#+begin_src go <<Iterate over internal nodes, Ch. \ref{ch:pc}>>=
  for i := n; i >= 2; i-- {
	  p := 2 * n - i
	  fmt.Printf("%d\t", p+1)
	  //<<Pick first child, Ch. \ref{ch:pc}>>
	  //<<Pick second child, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
We pick the first child according to lines 3 and 4 of
Algorithm~\ref{alg:coa} and print it. Then we replace the child by the
leftmost entry in the kindergarten (line 5).
#+end_export
#+begin_src go <<Pick first child, Ch. \ref{ch:pc}>>=
  c := int(float64(i) * ran.Float64())
  tree[p].child1 = tree[c]
  fmt.Printf("%d\t", c+1)
  tree[c] = tree[i]
#+end_src
#+begin_export latex
We pick the second child according to lines 6 and 7 of
Algorithm~\ref{alg:coa} and print it. Then we replace the child by its
parent, which thus enters the kindergarten.
#+end_export
#+begin_src go <<Pick second child, Ch. \ref{ch:pc}>>=
  c = int(float64(i-1) * ran.Float64())
  tree[p].child2 = tree[c]
  fmt.Printf("%d\n", c+1)
  tree[c] = tree[p]
#+end_src
#+begin_export latex
The program \ty{pickChildren} is finished, so let's test it.

\section*{Testing}
The outline of our test of \ty{pickChildren} has hooks for imports and
the testing logic.
#+end_export
#+begin_src go <<pickChildren_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch. \ref{ch:pc}>>
  )

  func TestPickChildren(t *testing.T) {
	  //<<Testing, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
We construct a set of tests, and run each one of them.
#+end_export
#+begin_src go <<Testing, Ch. \ref{ch:pc}>>=
  tests := make([]*exec.Cmd, 0)
  //<<Construct tests, Ch. \ref{ch:pc}>>
  for i, test := range tests {
	  //<<Run test, Ch. \ref{ch:pc}>>
  }
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:pc}>>=
  "os/exec"
#+end_src
#+begin_export latex
We run each test with the same seed for the random number generator to
keep the tests stable. Then we construct a test with default sample
size and one with sample size 4.
#+end_export
#+begin_src go <<Construct tests, Ch. \ref{ch:pc}>>=
  s := "3"
  test := exec.Command("./pickChildren", "-s", s)
  tests = append(tests, test)
  test = exec.Command("./pickChildren", "-s", s, "-n", "4")
  tests = append(tests, test)
#+end_src
#+begin_export latex
When running a test, we compare the result we get with the result we
want, which is stored in files \ty{r1.txt} and \ty{r2.txt}.
#+end_export
#+begin_src go <<Run test, Ch. \ref{ch:pc}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
  file := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := os.ReadFile(file)
  if err != nil {
	  t.Errorf("couldn't open %q", file)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{strconv}, \ty{os}, and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:pc}>>=
  "strconv"
  "os"
  "bytes"
#+end_src
