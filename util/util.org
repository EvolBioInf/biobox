#+begin_src latex
  !Package \texttt{util} contains data and functions used by many of the
  !programs collected in the \texttt{biobox}.

  The package outline provides hooks for imports, constants, types,
  variables, methods, and functions. Some of the computations are
  delegated to the GNU Scientific library, which is written in C. We
  therefore also provide hooks for dealing with C.
#+end_src
#+begin_src go <<util.go>>=
  package util
  //<<Deal with C, Ch.~\ref{ch:uti}>>
  import (
	  //<<Imports, Ch.~\ref{ch:uti}>>
  )
  const (
	  //<<Constants, Ch.~\ref{ch:uti}>>
  )
  //<<Types, Ch.~\ref{ch:uti}>>
  //<<Variables, Ch.~\ref{ch:uti}>>
  //<<Methods, Ch.~\ref{ch:uti}>>
  //<<Functions, Ch.~\ref{ch:uti}>>
#+end_src
#+begin_src latex
  To deal with C, we import \texttt{C}. Our bridge between Go and C is
  cgo, so there is a hook for cgo commands, and one for includes.
#+end_src
#+begin_src go <<Deal with C, Ch.~\ref{ch:uti}>>=
  /*
  //<<Cgo, Ch.~\ref{ch:uti}>>
  //<<Includes, Ch.~\ref{ch:uti}>>
  */
  import "C"
#+end_src
#+begin_src latex
  \section{Structure \texttt{Alignment}}
  !The structure \texttt{Alignment} holds the alignment of two
  !sequences.

  This structure is intended for uniform printing of pairwise sequence
  alignments. It holds two sequences, the score matrix, start positions
  of the two alignments---important for local alignments---the line
  length in the output, and the score.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:uti}>>=
  type Alignment struct {
	  sequence1, sequence2 *fasta.Sequence
	  scoreMatrix *ScoreMatrix
	  length1, length2, start1, start2, lineLength int
	  score float64
  }
#+end_src
#+begin_src latex
  \subsection*{Function \texttt{NewAlignment}}
  !\texttt{NewAlignment} takes as arguments two aligned sequences, the
  !score matrix used in computing the alignment, lengths of the two
  !sequences, start positions in the two sequences, and the score. The
  !start positions are zero-based.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func NewAlignment(seq1, seq2 *fasta.Sequence, sm *ScoreMatrix,
	  l1, l2, s1, s2 int, score float64) *Alignment {
	  al := new(Alignment)
	  //<<Set \texttt{Alignment} fields, Ch.~\ref{ch:uti}>>
	  return al
  }
#+end_src
#+begin_src go <<Set \texttt{Alignment} fields, Ch.~\ref{ch:uti}>>=
  al.sequence1 = seq1
  al.sequence2 = seq2
  al.scoreMatrix = sm
  al.lineLength = fasta.DefaultLineLength
  al.length1 = l1
  al.length2 = l2
  al.start1 = s1
  al.start2 = s2
  al.score = score
#+end_src
#+begin_src latex
  We import \texttt{fasta}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_src latex
  \subsection*{Method \texttt{SetLineLength}}
  An \texttt{Alignment} is immutable. Only the line length
  affects its appearance and hence is accessible via a setter.
  !\texttt{SetLineLength} sets the lengths of data lines in the printout
  !of an alignment. If the length passed is less than one, no change is
  !made.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:uti}>>=
  func (a *Alignment) SetLineLength(l int) {
	  if l > 0 {
		  a.lineLength = l
	  }
  }
#+end_src
#+begin_src latex
  \subsection*{Method \texttt{String}}
  !\texttt{String} converts an \texttt{Alignment} into a
  !printable string.

  This string has two parts, a header and the actual alignment. They are
  generated by writing to a byte buffer. An \texttt{Alignment} is
  terminated by \verb+//+.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:uti}>>=
  func (a *Alignment) String() string {
	  var buf []byte
	  buffer := bytes.NewBuffer(buf)
	  //<<Write header, Ch.~\ref{ch:uti}>>
	  //<<Write data, Ch.~\ref{ch:uti}>>
	  buffer.Write([]byte("//"))
	  return buffer.String()
  }
#+end_src
#+begin_src latex
  We import \texttt{bytes}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "bytes"
#+end_src
#+begin_src latex
  We write the header as a table, which is formatted via
  \texttt{tabwriter}.
#+end_src
#+begin_src go <<Write header, Ch.~\ref{ch:uti}>>=
  //<<Construct tabwriter, Ch.~\ref{ch:uti}>>
  //<<Write header to tabwriter, Ch.~\ref{ch:uti}>>
#+end_src
#+begin_src latex
  Our \texttt{tabwriter} writes to the \texttt{buffer}. Its minimal cell
  width is 1, the width of the tab characters is zero, a single
  character is added for padding, which is done by blanks.
#+end_src
#+begin_src go <<Construct tabwriter, Ch.~\ref{ch:uti}>>=
  w := new(tabwriter.Writer)
  w.Init(buffer, 1, 0, 1, ' ', 0)
#+end_src
#+begin_src latex
  We import \texttt{tabwriter}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "text/tabwriter"
#+end_src
#+begin_src latex
  The header consists of the names of the sequences, their role (query
  or subject), their lengths, and the alignment score.
#+end_src
#+begin_src go <<Write header to tabwriter, Ch.~\ref{ch:uti}>>=
  s1 := a.sequence1
  s2 := a.sequence2
  al := len(s2.Data())
  l1 := a.length1
  l2 := a.length2
  fmt.Fprintf(w, "Query\t%s\t(%d residues)\t\n", s1.Header(), l1)
  fmt.Fprintf(w, "Subject\t%s\t(%d residues)\t\n", s2.Header(), l2)
  fmt.Fprintf(w, "Score\t%g\t\n", a.score)
  w.Flush()
#+end_src
#+begin_src latex
  Having completed the header, we loop over the alignment and format it
  in triplets of lines consisting of the two sequences sandwiching a row
  of match characters. Figure~\ref{fig:al} shows an example, the
  alignment of two short peptides. Pairs of identical residues get
  vertical lines, distinct residues with scores greater than zero like
  phenylalanine (\texttt{F}) and tyrosine (\texttt{Y}) a colon, and
  mismatches or gaps blanks. We use the same \texttt{tabwriter} as for
  the header, and as for the header.
  \begin{figure}
  \begin{center}
    \begin{tabular}{lll}
      Query: 1 & \texttt{MKFLAL-F} & 7\\
	       & \texttt{||:| | |}\\
    Subject: 1 & \texttt{MKYLILLF} & 8
    \end{tabular}
  \end{center}
  \caption{Example alignment with the match characters sandwiched by the
    sequences.}\label{fig:al}
  \end{figure}
#+end_src
#+begin_src go <<Write data, Ch.~\ref{ch:uti}>>=
  //<<Declare variables, Ch.~\ref{ch:uti}>>
  for i := 0; i < al; i += a.lineLength {
	  //<<Compute line end, Ch.~\ref{ch:uti}>>
	  //<<Store sequences and match characters, Ch.~\ref{ch:uti}>>
  }
  w.Flush()
#+end_src
#+begin_src latex
  The variable \texttt{i} refers to the beginning of the line. Its end
  is either the beginning plus line length, or, if fewer residues than
  ``line length'' remain, the end of the alignment.
#+end_src
#+begin_src go <<Compute line end, Ch.~\ref{ch:uti}>>=
  if i + a.lineLength < al {
	  end = i + a.lineLength
  } else {
	  end = al
  }
#+end_src
#+begin_src latex
  We declare the variable \texttt{end}.
#+end_src
#+begin_src go <<Declare variables, Ch.~\ref{ch:uti}>>=
  var end int
#+end_src
#+begin_src latex
  In an alignment, two sequences sandwich a row of match characters
  (Figure~\ref{fig:al}). And while the sequences can be used as
  supplied, we still need to determine the match characters.
#+end_src
#+begin_src go <<Store sequences and match characters, Ch.~\ref{ch:uti}>>=
  //<<Store first sequence, Ch.~\ref{ch:uti}>>
  for j := i; j < end; j++ {
	  //<<Create slice of match characters, Ch.~\ref{ch:uti}>>
  }
  //<<Store match characters, Ch.~\ref{ch:uti}>>
  //<<Store second sequence, Ch.~\ref{ch:uti}>>
#+end_src
#+begin_src latex
  We generate a row-length slice of the first sequence in the
  alignment. The residues in this slice are its length minus the number
  of gaps. From the number of residues we compute the start and end
  positions in the underlying sequence. If the row contains at least one
  residue, the left border of the interval is advanced by one from the
  previous end, otherwise it remains unchanged.
#+end_src
#+begin_src go <<Store first sequence, Ch.~\ref{ch:uti}>>=
  data := s1.Data()[i:end]
  nr := len(data) - bytes.Count(data, []byte("-"))
  l := st1
  if nr > 0 { l++ }
  fmt.Fprintf(w, "\n\nQuery\t%d\t%s\t%d\t\n", l, data, st1+nr)
  st1 += nr
#+end_src
#+begin_src latex
  Here \texttt{s1} is the start of the first sequence.
#+end_src
#+begin_src go <<Declare variables, Ch.~\ref{ch:uti}>>=
  st1 := a.start1
#+end_src
#+begin_src latex
  The match characters are stored in a byte slice and are determined
  using the score matrix.
#+end_src
#+begin_src go <<Declare variables, Ch.~\ref{ch:uti}>>=
  var matches []byte
  sc := a.scoreMatrix
#+end_src
#+begin_src latex
  If neither of the characters compared is a gap, their match character
  is decided by looking up the score.
#+end_src
#+begin_src go <<Create slice of match characters, Ch.~\ref{ch:uti}>>=
  c1 := s1.Data()[j]
  c2 := s2.Data()[j]
  m := byte(' ')
  if c1 != '-' && c2 != '-' {
	  if c1 == c2 {
		  m = '|'
	  } else if sc.Score(c1, c2) > 0 {
		  m = ':'
	  }
  }
  matches = append(matches, m)
#+end_src
#+begin_src latex
  The match characters are handed to the \texttt{tabwriter} and reset.
#+end_src
#+begin_src go <<Store match characters, Ch.~\ref{ch:uti}>>=
  fmt.Fprintf(w, "\t\t%s\t\t\n", string(matches))
  matches = matches[:0]
#+end_src
#+begin_src latex
  To close the alignment sandwich, we add the second sequence, again
  framed by its start and end in the original.
#+end_src
#+begin_src go <<Store second sequence, Ch.~\ref{ch:uti}>>=
  data = s2.Data()[i:end]
  nr = len(data) - bytes.Count(data, []byte("-"))
  l = st2
  if nr > 0 { l++ }
  fmt.Fprintf(w, "Subject\t%d\t%s\t%d\t\n", l, data, st2+nr)
  st2 += nr
#+end_src
#+begin_src latex
  We declare and initialize the start of the second sequence.
#+end_src
#+begin_src go <<Declare variables, Ch.~\ref{ch:uti}>>=
st2 := a.start2
#+end_src
#+begin_src latex
  \section{Function \texttt{MeanVar}}
  !\texttt{MeanVar} takes as input a data set and returns its mean and
  !sample variance.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func MeanVar(data []float64) (float64, float64) {
	  var m, v float64
	  //<<Calculate mean, Ch.~\ref{ch:uti}>>
	  //<<Calculate variance, Ch.~\ref{ch:uti}>>
	  return m, v
  }
#+end_src
#+end_src
#+begin_src latex
  We calculate the mean,
#+end_src
#+begin_src go <<Calculate mean, Ch.~\ref{ch:uti}>>=
  n := len(data)
  for i := 0; i < n; i++ {
	  m += data[i]
  }
  m /= float64(n)
#+end_src
#+begin_src latex
  and the variance.
#+end_src
#+begin_src go <<Calculate variance, Ch.~\ref{ch:uti}>>=
  for i := 0; i < n; i++ {
	  s := m - data[i]
	  v += s * s
  }
  v /= float64(n - 1)
#+end_src
#+begin_src latex
  \section{Function \texttt{PrintInfo}}
  Each program in the biobox provides the same information on author,
  email, and license. These are stored as constants.
#+end_src
#+begin_src go <<Constants, Ch.~\ref{ch:uti}>>=
  author = "Bernhard Haubold"
  email = "haubold@evolbio.mpg.de"
  license = "Gnu General Public License, " +
	  "https://www.gnu.org/licenses/gpl.html"
#+end_src
#+begin_src latex
  !\texttt{PrintInfo} prints a program's name, version, and compilation
  !date. It also prints the author, email address, and license of the
  !\texttt{biobox} package. Then it exits. To achieve this, we wrap the
  !generic function for printing program information from the package
  !\texttt{clio}.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func PrintInfo(name string) {
	  clio.PrintInfo(name, version, date, author, email,
		  license)
	  os.Exit(0)
  }
#+end_src
#+begin_src latex
  We import \texttt{clio} and \texttt{os}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "github.com/evolbioinf/clio"
  "os"
#+end_src
#+begin_src latex
  The values of \texttt{Version} and \texttt{Date} are injected at
  compile-time. Here we just declare them.
#+end_src
#+begin_src go <<Variables, Ch.~\ref{ch:uti}>>=
  var version string
  var date string
#+end_src
#+begin_src latex
  \section{Structure \texttt{ScoreMatrix}}
  !A \texttt{ScoreMatrix} stores the scores of residue pairs.
  To save
  space, scores are 32-bit floats.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:uti}>>=
  type ScoreMatrix struct {
	  m [][]float32
  }
#+end_src
#+begin_src latex
  \subsection*{Function \texttt{NewScoreMatrix}}
  !Function \texttt{NewScoreMatrix} generates a new score matrix,
  !takes as input a match and a mismatch score, and stores them.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func NewScoreMatrix(match, mismatch float64) *ScoreMatrix {
	  sm := new(ScoreMatrix)
	  //<<Allocate score matrix, Ch.~\ref{ch:uti}>>
	  //<<Fill-in match scores, Ch.~\ref{ch:uti}>>
	  //<<Fill-in mismatch scores, Ch.~\ref{ch:uti}>>
	  return sm
  }
#+end_src
#+begin_src latex
  There are 95 printing ASCII characters. Not all of these are valid
  residues, but we simplify matters by allocating a $95\times
  95$ matrix.
#+end_src
#+begin_src go <<Allocate score matrix, Ch.~\ref{ch:uti}>>=
  n := 95
  sm.m = make([][]float32, n)
  for i := 0; i < n; i++ {
	  sm.m[i] = make([]float32, n)
  }
#+end_src
#+begin_src latex
  The match scores are on its main diagonal.
#+end_src
#+begin_src go <<Fill-in match scores, Ch.~\ref{ch:uti}>>=
  for i := 0; i < n; i++ {
	  sm.m[i][i] = float32(match)
  }
#+end_src
#+begin_src latex
  The mismatch scores are everywhere else.
#+end_src
#+begin_src go <<Fill-in mismatch scores, Ch.~\ref{ch:uti}>>=
  for i := 0; i < n - 1; i++ {
	  for j := i + 1; j < n; j++ {
		  sm.m[i][j] = float32(mismatch)
		  sm.m[j][i] = sm.m[i][j]
	  }
  }
#+end_src
#+begin_src latex
  \subsection*{Function \texttt{ReadScores}}
  !\texttt{ReadScores} reads scores from an \texttt{io.Reader}.

  Figure~\ref{fig:scoreMat} shows the BLOSUM62 score matrix. It starts with
  optional fenced-off comment lines, followed by a row of residues as
  column headers. Next are rows of values, each preceded by the residue
  in question. Columns are delimited by white space.

  \begin{figure}
    \small
  \begin{verbatim}
  #  Matrix made by matblas from blosum62.iij
  #  * column uses minimum score
  #  BLOSUM Clustered Scoring Matrix in 1/2 Bit Units
  #  Blocks Database = /data/blocks_5.0/blocks.dat
  #  Cluster Percentage: >= 62
  #  Entropy =   0.6979, Expected =  -0.5209
     A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  Z  X  *
  A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0 -2 -1 -1 -4 
  R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3 -1  0 -1 -4 
  N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  3  0 -1 -4 
  D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  4  1 -1 -4 
  C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1 -3 -3 -1 -4 
  Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0  3 -1 -4 
  E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  1  4 -1 -4 
  G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3 -1 -2 -1 -4 
  H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0  0 -1 -4 
  I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3 -3 -3 -1 -4 
  L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1 -4 -3 -1 -4 
  K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0  1 -1 -4 
  M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1 -3 -1 -1 -4 
  F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1 -3 -3 -1 -4 
  P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2 -2 -1 -1 -4 
  S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0  0 -1 -4 
  T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0 -1 -1 -1 -4 
  W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3 -4 -3 -1 -4 
  Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1 -3 -2 -1 -4 
  V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4 -3 -2 -1 -4 
  B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  4  1 -1 -4 
  Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  1  4 -1 -4 
  X -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -4 
  ,* -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  1 
  \end{verbatim}
  \caption{The BLOSUM62 amino acid substitution matrix for scoring
    aligned pairs of amino acids.}\label{fig:scoreMat}
  \end{figure}

  For reading scores, we prepare two variables. The boolean
  \texttt{first} marks the first line of the table; the slice of byte
  slices \texttt{res} holds the residues used as column headers in that
  line. Then we scan the input.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func ReadScoreMatrix(r io.Reader) *ScoreMatrix {
	  s := NewScoreMatrix(1, -1)
	  first := true
	  var res [][]byte
	  sc := bufio.NewScanner(r)
	  for sc.Scan() {
		  b := sc.Bytes()
		  //<<Deal with score table, Ch.~\ref{ch:uti}>>
	  }
	  return s
  }
#+end_src
#+begin_src latex
  We import \texttt{io} and \texttt{bufio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "io"
  "bufio"
#+end_src
#+begin_src latex
  As shown in Figure~\ref{fig:scoreMat}, the first line that isn't
  fenced off, is the table header, the others make up its body.
#+end_src
#+begin_src go <<Deal with score table, Ch.~\ref{ch:uti}>>=
  if b[0] != '#' {
	  if first {
		  //<<Deal with header, Ch.~\ref{ch:uti}>>
	  } else {
		  //<<Deal with body, Ch.~\ref{ch:uti}>>
	  }
  }
#+end_src
#+begin_src latex
  The header line is split into individual headers, and we remember
  not to do that again.
#+end_src
#+begin_src go <<Deal with header, Ch.~\ref{ch:uti}>>=
  res = bytes.Fields(b)
  first = false
#+end_src
#+begin_src latex
  We import \texttt{bytes}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "bytes"
#+end_src
#+begin_src latex
  The body of the table is split into entries, of which the first is a
  residue and the others are scores.
#+end_src
#+begin_src go <<Deal with body, Ch.~\ref{ch:uti}>>=
  entries := bytes.Fields(b)
  for i := 1; i < len(entries); i++ {
	  c1 := entries[0][0]
	  c2 := res[i-1][0]
	  score, err := strconv.ParseFloat(string(entries[i]), 64)
	  if err != nil {
		  log.Fatalf("couldn't parse %q\n", entries[i])
	  }
	  s.setScore(c1, c2, score)
  }
#+end_src
#+begin_src latex
  We import \texttt{strconv} and \texttt{log}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "strconv"
  "log"
#+end_src
#+begin_src latex
  \subsection*{Method \texttt{Score}}
  !The method \texttt{Score} takes two characters as arguments and
  !returns their score. If one of the characters is not a printing ASCII
  !character, it returns the smallest float and prints a warning.

  We first check we have a pair of valid characters, then return the
  corresponding score as a 64-bit float, because that is the standard
  currency of numerical work.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:uti}>>=
  func (s *ScoreMatrix) Score(c1, c2 byte) float64 {
	  c1 -= 32
	  c2 -= 32
	  if c1 < 0 || c1 > 94 || c2 < 0 || c2 > 94 {
		  fmt.Fprintf(os.Stderr, "couldn't score " +
			  "(%q, %q)\n",	c1, c2)
		  return -math.MaxFloat64
	  }
	  return float64(s.m[c1][c2])
  }
#+end_src
#+begin_src latex
  We import \texttt{fmt} and \texttt{math}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "fmt"
  "math"
#+end_src
#+begin_src latex
  \subsection*{Method \texttt{setScore}}
  The method \texttt{setScore} takes as argument two characters and
  their score, and stores the triple.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:uti}>>=
  func (s *ScoreMatrix) setScore(c1, c2 byte, sc float64) {
	  c1 -= 32
	  c2 -= 32
	  if c1 < 0 || c1 > 94 || c2 < 0 || c2 > 94 {
		  fmt.Fprintf(os.Stderr, "couldn't score " +
			  "(%q, %q)\n", c1, c2)
	  }
	  s.m[c1][c2] = float32(sc)
  }
#+end_src
#+begin_src latex
  \section{Structure \texttt{TransitionTab}}
  !A \texttt{transitionTab} indicates whether or not a pair of
  !nucleotides represents a transition. Nucleotides come in two types,
  !the purines, \texttt{A} and \texttt{G}, and the pyrimidines,
  !\texttt{C} and \texttt{T}. Mutations within a chemical class are
  !called transitions, as opposed to transversions, mutations between
  !the classes.

  The structure holds a two-dimensional table of booleans. Nucleotides
  come as bytes and the are used as indexes into the table. The
  nucleotide alphabet starts at an \emph{offset} from the ASCII
  alphabet and is $n$ characters long.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:uti}>>=
  type TransitionTab struct {
	  offset, n byte
	  ts [][]bool
  }
#+end_src
#+begin_src latex
  \subsection*{Function \texttt{NewTransitionTab}}
  !\texttt{NewTransitionTab} constructs and initializes a new
  !\texttt{TransitionTab}.

  The table caters for nucleotides in caps, of which the smallest is
  \texttt{A}, decimal 65, and the largest \texttt{T}, 84. Hence the
  offset is 65 and $n=84-65 + 1=20$ characters are accounted for.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func NewTransitionTab() TransitionTab {
	  var tab TransitionTab
	  tab.offset = 65
	  tab.n = 20
	  //<<Make transition table, Ch.~\ref{ch:uti}>>
	  //<<Enter transitions, Ch.~\ref{ch:uti}>>
	  return tab
  }
#+end_src
#+begin_src latex
  The transition table is a slice of boolean slices.
#+end_src
#+begin_src go <<Make transition table, Ch.~\ref{ch:uti}>>=
  tab.ts = make([][]bool, tab.n)
  for i := 0; i < int(tab.n); i++ {
	  tab.ts[i] = make([]bool, tab.n)
  }
#+end_src
#+begin_src latex
  We fill in the transition table to get:
  \begin{center}
    \begin{tabular}{c|cccc}
      & \texttt{A} & \texttt{C} & \texttt{G} & \texttt{T}\\\hline
      \texttt{A} & false & false & true & false\\
      \texttt{C} & false & false & false & true\\
      \texttt{G} & true & false & false & false\\
      \texttt{T} & false & true & false & false\\
    \end{tabular}
  \end{center}
#+end_src
#+begin_src go <<Enter transitions, Ch.~\ref{ch:uti}>>=
  a := byte('A') - tab.offset
  c := byte('C') - tab.offset
  g := byte('G') - tab.offset
  t := byte('T') - tab.offset
  tab.ts[a][g] = true
  tab.ts[c][t] = true
  tab.ts[g][a] = true
  tab.ts[t][c] = true
#+end_src
#+begin_src latex
  \subsection*{Method \texttt{IsTransition}}
  !\texttt{IsTransition} takes a pair of nucleotides as arguments and
  !returns true if they are both caps and represent a transition, false
  !otherwise.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:uti}>>=
  func (t TransitionTab) IsTransition(a, b byte) bool {
	  a -= t.offset
	  b -= t.offset
	  if a < 0 || b < 0 || a >= t.n || b >= t.n {
		  return false
	  }
	  return t.ts[a][b]
  }
#+end_src
#+begin_src latex
  \section{Function \texttt{TTest}}
  !\texttt{TTest} tests the equality of two sample means. It takes as
  !input two samples and returns their means,  the value of $t$, and its
  !significance, $p$. It runs with equal variance (original Student's
  !t-test), or with unequal variances (Welch's test)

  For Student's t-test, $t$ is defined as
  \begin{equation}\label{eq:t1}
    t = \frac{m_1-m_2}{s_p\sqrt{1/n_1 + 1/n_2}},
  \end{equation}
  where $m_1$ and $m_2$ are the sample means, $n_1$ and $n_2$ their
  sizes, and $s_p$ the pooled standard deviation,
  \[
  s_p=\sqrt{\frac{(n_1-1)v_1+(n_2-1)v_2}{n_1+n_2-2}},
  \]
  where $v_1$ and $v_2$ are the sample variances. The degrees of freedom
  for significance testing are 
  \begin{equation}\label{eq:d1}
    d=n_1+n_2-2.
  \end{equation}

  For Welch's t-test, we have
  \begin{equation}\label{eq:t2}
  t=\frac{m_1-m_2}{\sqrt{v_1/n_1+v_2/n_2}}.
  \end{equation}
  In this case the degrees of freedom are
  \begin{equation}\label{eq:d2}
  d = \frac{\left(v_1/n_1+v_2/n_2\right)^2}{
    v_1^2/n_1^2/(n_1-1) + v_2^2/n_2^2/(n_2-1)
  }.
  \end{equation}
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func TTest(d1, d2 []float64, equalVar bool) (m1, m2, t, p float64) {
	  //<<Compute means and variances, Ch.~\ref{ch:uti}>>
	  //<<Compute $t$ and degrees of freedom, Ch.~\ref{ch:uti}>>
	  //<<Compute $P$-value, Ch.~\ref{ch:uti}>>
	  return m1, m2, t, p
  }
#+end_src
#+begin_src latex
  Means and variances are calculated in a single function.
#+end_src
#+begin_src go <<Compute means and variances, Ch.~\ref{ch:uti}>>=
  m1, v1 := MeanVar(d1)
  m2, v2 := MeanVar(d2)
#+end_src
#+begin_src latex
  The value of the test statistic, $t$, depends on whether or not we are
  dealing with equal variances.
#+end_src
#+begin_src go <<Compute $t$ and degrees of freedom, Ch.~\ref{ch:uti}>>=
  var d float64
  n1 := float64(len(d1))
  n2 := float64(len(d2))
  if equalVar {
	  //<<Equal variances, Ch.~\ref{ch:uti}>>
  } else {
	  //<<Unequal variances, Ch.~\ref{ch:uti}>>
  }
#+end_src
#+begin_src latex
  For the equal-variance case we transcribe equations~(\ref{eq:t1}) and
  (\ref{eq:d1}).
#+end_src
#+begin_src go <<Equal variances, Ch.~\ref{ch:uti}>>=
  x := (n1 - 1.0) * v1 + (n2 - 1.0) * v2
  if x == 0 {
	  log.Fatal("util.TTest: Error, data constant.\n")
  }
  d  = n1 + n2 - 2.0
  if d == 0 {
	  log.Fatal("util.TTest: Error, samples too small.\n")
  }
  sp := math.Sqrt(x/d)
  x = sp * math.Sqrt(1.0/n1 + 1.0/n2)
  t = (m1 - m2) / x
#+end_src
#+begin_src latex
  For the unequal-variance case we transcribe equations~(\ref{eq:t2})
  and (\ref{eq:d2}).
#+end_src
#+begin_src go <<Unequal variances, Ch.~\ref{ch:uti}>>=
  t = (m1 - m2) / math.Sqrt(v1/n1 + v2/n2)
  x := (v1/n1 + v2/n2) * (v1/n1 + v2/n2)
  y := v1*v1/n1/n1/(n1-1.0) + v2*v2/n2/n2/(n2-1.0)
  if y == 0 {
	  log.Fatal("util.TTest: Error, data constant.\n")
  }
  d = x / y
#+end_src
#+begin_src latex
  For the significance computation we call the cumulative density
  function of the $t$-distribution provided by the Gnu Scientific
  Library. This is written in C and we use cgo to communicate between C
  and Go.
#+end_src
#+begin_src go <<Compute $P$-value, Ch.~\ref{ch:uti}>>=
  ct := C.double(t)
  cd := C.double(d)
  if t > 0 {
	  p = float64(C.gsl_cdf_tdist_Q(ct, cd)) * 2.0
  } else {
	  p = float64(C.gsl_cdf_tdist_P(ct, cd)) * 2.0
  }
#+end_src
#+begin_src latex
  We add the GSL to cgo and make sure the build also works on macOS with
  homebrew.
#+end_src
#+begin_src go <<Cgo, Ch.~\ref{ch:uti}>>=
  #cgo CFLAGS: -I/opt/homebrew/include
  #cgo LDFLAGS: -lgsl -lgslcblas -L/opt/homebrew/lib
#+end_src
#+begin_src latex
  We also include the header for the cumulative density functions.
#+end_src
#+begin_src go <<Includes, Ch.~\ref{ch:uti}>>=
  #include <gsl/gsl_cdf.h>
#+end_src
#+begin_export latex
\section{\ty{PrepLog}}
In \ty{CheckGnuplot} and elsewhere, we handle errors via the \ty{log}
package. By default, this prefixes the error message with time and
date. Instead, we'd like error messages prefixed with the name of the
program and with date and time suppressed.

!\ty{PrepLog} takes as argument the program name and sets
!this as the prefix for error messages from the \ty{log} package.
#+end_export
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func PrepLog(name string) {
	  m := fmt.Sprintf("%s: ", name)
	  log.SetPrefix(m)
	  log.SetFlags(0)
  }
#+end_src
#+begin_export latex
We import \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:uti}>>=
  "fmt"
#+end_src
#+begin_src latex
  \section{Testing}
  The testing outline contains hooks for imports, types, and the testing
  logic.
#+end_src
#+begin_src go <<util_test.go>>=
  package util

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:uti}>>
  )
  //<<Testing types, Ch.~\ref{ch:uti}>>
  func TestUtil(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:uti}>>
  }
#+end_src
#+begin_src latex
  \subsection*{\texttt{Alignment}}
  We begin our test of \texttt{Alignment} by constructing one from the
  two peptide sequences shown in Figure~\ref{fig:al}.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:uti}>>=
  s1 := fasta.NewSequence("s1", []byte("MKFLAL-F"))
  s2 := fasta.NewSequence("s2", []byte("MKYLILLF"))
  sf, err := os.Open("BLOSUM62")
  if err != nil {
	  t.Error("couldn't open BLOSUM62\n")
  }
  sm := ReadScoreMatrix(sf)
  sf.Close()
  al := NewAlignment(s1, s2, sm, 7, 8, 0, 0, 19)
#+end_src
#+begin_src latex
  We import \texttt{fasta} and \texttt{os}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:uti}>>=
  "github.com/evolbioinf/fasta"
  "os"
#+end_src
#+begin_src latex
  Now we compare what we get with what we want, which is stored in the
  file \texttt{res1.txt}. The data in the file is terminated by an extra
  newline, so we add one to what we compute.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:uti}>>=
  get := []byte(al.String())
  get = append(get, '\n')
  want, err := ioutil.ReadFile("res1.txt")
  if err != nil {
	  t.Error("couldn't open res1.txt\n")
  }
  if !bytes.Equal(want, get) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src latex
  We import \texttt{ioutil} and \texttt{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:uti}>>=
  "io/ioutil"
  "bytes"
#+end_src
#+begin_src latex
  Now we set the line length to 4.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:uti}>>=
  al.SetLineLength(4)
  get = []byte(al.String())
  get = append(get, '\n')
  want, err = ioutil.ReadFile("res2.txt")
  if err != nil {
	  t.Error("couldn't open res2.txt\n")
  }
  if !bytes.Equal(want, get) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src latex
  We test the \texttt{ScoreMatrix} by sampling four residue pairs.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:uti}>>=
  w := []float64{4, -1, 4, -4}
  g := make([]float64, 4)
  g[0] = sm.Score('A', 'A')
  g[1] = sm.Score('A', 'R')
  g[2] = sm.Score('B', 'B')
  g[3] = sm.Score('*', 'X')
  for i := 0; i < 4; i++ {
	  if w[i] != g[i] {
		  t.Errorf("want:\n%g\nget:\n%g\n", w[i], g[i])
	  }
  }
#+end_src
#+begin_src latex
  We continue the test by setting the score for \ty{F} and \ty{Y} to
  zero and observing that the similarity character, \verb+:+ changes to
  blank.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:uti}>>=
  al.scoreMatrix.setScore('Y', 'F', 0)
  al.scoreMatrix.setScore('F', 'Y', 0)
  get = []byte(al.String())
  get = append(get, '\n')
  want, err = ioutil.ReadFile("res3.txt")
  if err != nil {
	  t.Error("couldn't open res3.txt")
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("3 want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src latex
  \subsection*{\texttt{TransitionTab}}
  To test \texttt{TransitionTab}, we set up some tests and run them.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:uti}>>=
  tab := NewTransitionTab()
  //<<Set up transition tests, Ch.~\ref{ch:uti}>>
  //<<Run transition tests, Ch.~\ref{ch:uti}>>
#+end_src
#+begin_src latex
  Each test consists of three values, two characters and the boolean
  wanted. We set up the structure \texttt{triplet} to hold these values.
#+end_src
#+begin_src go <<Testing types, Ch.~\ref{ch:uti}>>=
  type triplet struct {
	  a, b byte
	  w bool
  }
#+end_src
#+begin_src latex
  We set up the table of tests.
#+end_src
#+begin_src go <<Set up transition tests, Ch.~\ref{ch:uti}>>=
  tr := make([]triplet, 8)
  tr = append(tr, triplet{a: 'A', b: 'G', w: true})
  tr = append(tr, triplet{a: 'G', b: 'A', w: true})
  tr = append(tr, triplet{a: 'C', b: 'T', w: true})
  tr = append(tr, triplet{a: 'T', b: 'C', w: true})
  tr = append(tr, triplet{a: 'A', b: 'C', w: false})
  tr = append(tr, triplet{a: 'T', b: 'T', w: false})
  tr = append(tr, triplet{a: 'T', b: 't', w: false})
  tr = append(tr, triplet{a: '!', b: 'A', w: false})
#+end_src
#+begin_src latex
  If a pair of characters is misclassified, the test fails.
#+end_src
#+begin_src go <<Run transition tests, Ch.~\ref{ch:uti}>>=
  for _, test := range tr {
	  g := tab.IsTransition(test.a, test.b)
	  if g != test.w {
		  t.Errorf("misclassified (%c, %c)\n", test.a, test.b)
	  }
  }
#+end_src
#+begin_src latex
  \subsection*{\texttt{TTest}}
  We create a file for storing the results of our t-test. Once carried
  out, we compare the results of our test with the results we want,
  before deleting the file again.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:uti}>>=
  //<<Create file for t-test, Ch.~\ref{ch:uti}>>
  //<<Carry out t-test and save results, Ch.~\ref{ch:uti}>>
  //<<Compare t-test results, Ch.~\ref{ch:uti}>>
  //<<Remove file for t-test, Ch.~\ref{ch:uti}>>
#+end_src
#+begin_src latex
  We open a file to store our results in and throw an error if we can't.
#+end_src
#+begin_src go <<Create file for t-test, Ch.~\ref{ch:uti}>>=
fn := "tmp.txt"
outf, err := os.Create(fn)
if err != nil {
	t.Errorf("couldn't open %q\n", fn)
}
#+end_src
#+begin_src latex
  We construct two data sets and carry out the test with equal variances
  and without.
#+end_src
#+begin_src go <<Carry out t-test and save results, Ch.~\ref{ch:uti}>>=
  d1 := []float64{11.961,12.401,11.661,11.96,10.454,11.584,11.175}
  d2 := []float64{8.479,8.523,8.793,8.726,9.677,8.728,8.383,11.086}
  m1, m2, st, p := TTest(d1, d2, true)
  fmt.Fprintf(outf, "%.8g %.8g %.8g %.8g\n", m1, m2, st, p)
  m1, m2, st, p = TTest(d1, d2, false)
  fmt.Fprintf(outf, "%.8g %.8g %.8g %.8g\n", m1, m2, st, p)
  outf.Close()
#+end_src
#+begin_src latex
  We import \texttt{fmt}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:uti}>>=
  "fmt"
#+end_src
#+begin_src latex
  The file \texttt{res4.txt} contains the results we want, which we
  compare to what we get.
#+end_src
#+begin_src go <<Compare t-test results, Ch.~\ref{ch:uti}>>=
  want, err = ioutil.ReadFile("res4.txt")
  if err != nil {
	  t.Errorf("couldn't open res4.txt\n")
  }
  get, err  = ioutil.ReadFile(fn)
  if err != nil {
	  t.Errorf("couldn't open %q\n", fn)
  }
  if !bytes.Equal(want, get) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src go <<Remove file for t-test, Ch.~\ref{ch:uti}>>=
  err = os.Remove(fn)
  if err != nil {
	  t.Errorf("couldn't remove %q\n", fn)
  }
#+end_src
#+begin_export latex
\section{Function \ty{CheckGnuplot}}
!\ty{CheckGnuplot} checks the error returned by a \ty{gnuplot} run.
#+end_export
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func CheckGnuplot(err error) {
	  if err != nil {
		  m := "Error when plotting with gnuplot; "
		  m += "you might like to try a different terminal. "
		  m += "To get the list of available terminals, "
		  m += "start gnuplot and enter \"set term\"."
		  log.Fatal(m)
	  }
  }
#+end_src
#+begin_export latex
\section{Function \ty{IsInteractive}}
!\ty{IsInteractive} checks whether a gnuplot terminal is interactive
!or not.
#+end_export
#+begin_src go <<Functions, Ch.~\ref{ch:uti}>>=
  func IsInteractive(t string) bool {
	  ii := false
	  if t == "wxt" || t == "x11" || t == "qt" ||
		  t == "aqua" || t == "windows" {
		  ii = true
	  }
	  return ii
  }
#+end_src
