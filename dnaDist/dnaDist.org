#+begin_src latex
  \section*{Introduction}
  Given a stet of aligned DNA sequences, \texttt{dnaDist} computes their
  pairwise distances. Perhaps the simplest distance measure is the raw
  mismatch count, and \ty{dnaDist} implements that, as well as the
  number of mismatches per base. The mismatches per base are allow
  computation of two classical distance measures, known by their
  inventors' names, Jukes-Cantor~\cite{juk69:evo} and
  Kimura~\cite{kim80:sim}.

  When computing the Jukes-Cantor distance, all mutations are treated
  the same, regardless of the base changed. Let $\pi$ be the
  number of mismatches per site between a pair of sequences. Since
  positions can mutate more than once, the number of mismatches may be
  smaller than the number of mutations, or substitutions, that took
  place in the past. The Jukes-Cantor distance corrects for this.
  \begin{equation}\label{eq:jc}
    J=-\frac{3}{4}\log\left(1-\frac{4\pi}{3}\right).
  \end{equation}

  As shown in Figure~\ref{fig:jc}, $J\approx\pi$ for small values of
  $\pi$. But as $\pi$ increases, $J$ grows much quicker, until at
  saturation, when $\pi=3/4$, $J$ becomes infinity.
  \begin{figure}[ht]
    \begin{center}
      \scalebox{0.6}{\input{jc}}
      \end{center}
    \caption{The number of substitutions per site, $J$, as a function of
      the number of mismatches per site, $\pi$.}\label{fig:jc}
  \end{figure}

  For the Kimura distance, purines, \texttt{A} and \texttt{G}, are
  distinguished from pyrimidines, \texttt{C} and \texttt{T}. Mutations
  within the chemical class are called transitions, between the classes
  transversions. Let $\alpha$ be the number of transitions per site
  between two sequences, and $\beta$ the number of transversions. Their
  sum is the number of mismatches, $\pi=\alpha+\beta$. The Kimura
  distance is then
  \begin{equation}\label{eq:kim}
    K=-\frac{1}{2}\log\left(\left(1-2\alpha-\beta\right)\sqrt{1-2\beta}\right).
  \end{equation}

  When calculating pairwise mismatches, we ignore comparisons between
  pairs of gaps or between a gap and a residue.

  Distance matrices are usually summarized as phylogenies, which
  routinely come with support values attached to internal nodes that
  quantify the reliability of the group of organisms in the subtree
  rooted on that node. A popular method for calculating these support
  values is the bootstrap~\cite{fel85:con}. The bootstrap is a widely
  used technique in statistics for simulating repeated
  sampling~\cite{efr93:int}. In the case of \texttt{dnaDist}, the
  underlying multiple sequence alignment is resampled. If this consists
  of an $m\times n$ table of residues, where $m$ is the number of taxa
  and $n$ the alignment length, a bootstrap sample is generated by
  randomly drawing $n$ columns. This is done \emph{with replacement},
  which means that some columns are drawn repeatedly, others not at
  all. Given such a bootstrap sample, distances are computed and output,
  and this bootstrapping is repeated, say $10^4$ times.

  \section*{Implementation}
  The outline of \texttt{dnaDist} contains hooks for imports, types,
  functions, and the logic of the main function.
#+end_src
#+begin_src go <<dnaDist.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:dna}>>
  )
  //<<Types, Ch.~\ref{ch:dna}>>
  //<<Functions, Ch.~\ref{ch:dna}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  In the main function, we set the usage, declare the options and parse
  them, and parse the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:dna}>>=
  //<<Set usage, Ch.~\ref{ch:dna}>>
  //<<Declare options, Ch.~\ref{ch:dna}>>
  //<<Parse options, Ch.~\ref{ch:dna}>>
  //<<Parse input files, Ch.~\ref{ch:dna}>>
#+end_src
#+begin_src latex
  The usage consists of a message, an explanation of the program's
  purpose, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:dna}>>=
  u := "dnaDist [-h] [options] [file(s)]"
  p := "Calculate distances between DNA sequences."
  e := "dnaDist foo.fasta"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \texttt{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  We declare six options: \texttt{-v} to print the program version,
  \ty{-r} to give the raw mismatch count, \ty{-u} for the uncorrected
  distances, \texttt{-k} to compute Kimura instead of Jukes-Cantor
  distances, and \texttt{-b} to specify the number of bootstrap
  replicates, by default none. Bootstrapping requires random numbers,
  and their generator can be seeded via \texttt{-s} to generate exact
  repeats.
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:dna}>>=
  var optV = flag.Bool("v", false, "version")
  var optR = flag.Bool("r", false, "raw mismatches")
  var optU = flag.Bool("u", false, "uncorrected mismatches")
  var optK = flag.Bool("k", false, "Kimura distances (default: Jukes-Cantor)")
  var optB = flag.Int("b", 0, "number of bootstrap replicates")
  var optS = flag.Int("s", 0, "seed for random number generator " +
	  "(default: internal)")
#+end_src
#+begin_src latex
  We import \texttt{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "flag"
#+end_src
#+begin_src latex
  When parsing options, \texttt{-v} and \texttt{-b} require action at
  this point.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:dna}>>=
  flag.Parse()
  //<<Respond to \texttt{-v}, Ch.~\ref{ch:dna}>>
  //<<Respond to \texttt{-b}, Ch.~\ref{ch:dna}>>
#+end_src
#+begin_src latex
  If the user requested version printing, we call a dedicated function
  that takes the program name as argument.
#+end_src
#+begin_src go <<Respond to \texttt{-v}, Ch.~\ref{ch:dna}>>=
if *optV {
	util.PrintInfo("dnaDist")
}
#+end_src
#+begin_src latex
    We import \texttt{util}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_src latex
  As to the number of bootstrap replicates, two cases require attention:
  Less than zero, where the user made a mistake, and more than zero,
  where the user requested bootstrapping.
#+end_src
#+begin_src go <<Respond to \texttt{-b}, Ch.~\ref{ch:dna}>>=
  //<<Less than zero replicates, Ch.~\ref{ch:dna}>>
  //<<More than zero replicates, Ch.~\ref{ch:dna}>>
#+end_src
#+begin_src latex
If the user requested a
negative number of bootstrap replicates, this is set to zero and the
user warned. 
#+end_src
#+begin_src go <<Less than zero replicates, Ch.~\ref{ch:dna}>>=
if *optB < 0 {
	fmt.Fprintf(os.Stderr, "resetting %d bootstrap " +
		"replicates to zero", *optB)
	*optB = 0
}
#+end_src
#+begin_src latex
  We import \texttt{fmt} and \texttt{os}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "fmt"
  "os"
#+end_src
#+begin_src latex
  If the user requested at least one bootstrap replicate, the random
  number generator is seeded. If no seed is provided, it is generated
  internally.
#+end_src
#+begin_src go <<More than zero replicates, Ch.~\ref{ch:dna}>>=
  var ran *rand.Rand
  if *optB > 0 {
	  if *optS != 0 {
		  ran = rand.New(rand.NewSource(int64(*optS)))
	  } else {
		  t := time.Now().UnixNano()
		  ran = rand.New(rand.NewSource(t))
	  }
  }
#+end_src
#+begin_src latex
  We import \texttt{rand} and \texttt{time}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "math/rand"
  "time"
#+end_src
#+begin_src latex
  We parse the input files using the function \texttt{parseFiles}. It
  takes as input the names of the input files, a function applied to
  each of these files, and the arguments of that function. These
  arguments are the values of \ty{-b}, \ty{-r}, \ty{-u}, \texttt{-k}, the random
  number generator, and a matrix for looking up transitions.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:dna}>>=
  files := flag.Args()
  ts := util.NewTransitionTab()
  clio.ParseFiles(files, scan, *optB, *optR, *optU, *optK, ran, ts)
#+end_src
#+begin_src latex
  In the function \texttt{scan}, we retrieve the options just passed,
  read the input file, convert it to a multiple sequence alignment, and
  calculate the pairwise distances from it.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:dna}>>=
  func scan(r io.Reader, args ...interface{}) {
	  //<<Retrieve options, Ch.~\ref{ch:dna}>>
	  //<<Read input file, Ch.~\ref{ch:dna}>>
	  //<<Construct multiple sequence alignment, Ch.~\ref{ch:dna}>>
	  //<<Calculate distances, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  We import \texttt{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "io"
#+end_src
#+begin_src latex
  The values of six options were passed, the number of bootstrap
  replicates (\ty{-b}), raw distances (\ty{-r}), uncorrected
  mismatches (\ty{-u}), Kimura distances (\texttt{-k}), the random
  number generator, and the transition table. We retrieve them by type
  assertion.
#+end_src
#+begin_src go <<Retrieve options, Ch.~\ref{ch:dna}>>=
  optB := args[0].(int)
  optR := args[1].(bool)
  optU := args[2].(bool)
  optK := args[3].(bool)
  ran  := args[4].(*rand.Rand)
  ts   := args[5].(util.TransitionTab)
#+end_src
#+begin_src latex
  When reading the input file, the sequences are stored in a slice of
  sequences. To make sure the sequences are in fact aligned, we check
  their lengths.
#+end_src
#+begin_src go <<Read input file, Ch.~\ref{ch:dna}>>=
  sc := fasta.NewScanner(r)
  var sa []*fasta.Sequence
  for sc.ScanSequence() {
	  sa = append(sa, sc.Sequence())
	  //<<Check sequence lengths, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  We import \texttt{fasta}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_src latex
  When we find a variation in the sequence length, we are not dealing
  with an alignment and abort.
#+end_src
#+begin_src go <<Check sequence lengths, Ch.~\ref{ch:dna}>>=
  if len(sa) > 1 {
	  i := len(sa) - 1
	  if len(sa[i].Data()) != len(sa[i-1].Data()) {
		  fmt.Fprintf(os.Stderr, "this doesn't look " +
			  "like an alignment\n")
		  os.Exit(-1)
	  }
  }
#+end_src
#+begin_src latex
  A multiple sequence alignment is a two-dimensional table of
  bytes. When computing distances, all pairwise comparisons between the
  residues in a column need to be made. This is only necessary for
  polymorphic columns and we can potentially save a lot of work by
  ignoring monomorphic columns. Hence we augment the multiple sequence
  alignment by a table of polymorphic sites.
#+end_src
#+begin_src go <<Construct multiple sequence alignment, Ch.~\ref{ch:dna}>>=
  //<<Construct byte table, Ch.~\ref{ch:dna}>>
  //<<Construct polymorphism table, Ch.~\ref{ch:dna}>>
#+end_src
#+begin_src latex
  We construct an $m\times n$ table of residues, which are set to upper
  case.
#+end_src
#+begin_src go <<Construct byte table, Ch.~\ref{ch:dna}>>=
  m := len(sa)
  n := len(sa[0].Data())
  msa := make([][]byte, m)
  for i, s := range sa {
	  msa[i] = bytes.ToUpper(s.Data())
  }
#+end_src
#+begin_src latex
  We import \texttt{bytes}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "bytes"
#+end_src
#+begin_src latex
  The polymorphism table consists of booleans for each column; if
  \emph{true}, the position is polymorphic.
#+end_src
#+begin_src go <<Construct polymorphism table, Ch.~\ref{ch:dna}>>=
  pol := make([]bool, n)
  gap := byte('-')
  for j := 0; j < n; j++ {
	  for i := 0; i < m; i++ {
		  if msa[i][j] != gap && msa[i][j] != msa[0][j] {
			  pol[j] = true
			  break
		  }
	  }
  }
#+end_src
#+begin_src latex
  When calculating distances, this is done either with or without
  bootstrapping. Wit bootstrapping, we sample with replacement columns
  of the residue table. We do this with an indicator table containing
  the positions from which the distances are computed. The distance
  matrix is constructed at the beginning and reused throughout the
  bootstrap.
#+end_src
#+begin_src go <<Calculate distances, Ch.~\ref{ch:dna}>>=
  ind := make([]int, n)
  //<<Make distance matrix, Ch.~\ref{ch:dna}>>
  if optB > 0 {
	  //<<With bootstrap, Ch.~\ref{ch:dna}>>
  } else {
	  //<<Without bootstrap, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  The distance matrix is an $n\times n$ table of cells.
#+end_src
#+begin_src go <<Make distance matrix, Ch.~\ref{ch:dna}>>=
  dm := make([][]cell, m)
  for i := 0; i < m; i++ {
	  dm[i] = make([]cell, m)
  }
#+end_src
#+begin_src latex
  Each cell consists of two integers, the raw counts that go into the
  computation of $\alpha$, $\beta$, and a float holding the final
  distance, $d$.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:dna}>>=
  type cell struct {
	  a, b int
	  d float64
  }
#+end_src
#+begin_src latex
  With bootstrap, we resample the column indexes, then compute the
  distance, and finally print them. Since distance computation and
  printing is the same without bootstrap, these steps are delegated to
  functions.
#+end_src
#+begin_src go <<With bootstrap, Ch.~\ref{ch:dna}>>=
  for i := 0; i < optB; i++ {
	  //<<Bootstrap indexes, Ch.~\ref{ch:dna}>>
	  distMat(dm, msa, pol, ind, optR, optU, optK, ts)
	  printDist(dm, sa)
	  //<<Reset distance matrix, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  Bootstrapping the indexes consists of drawing $n$ random numbers
  between zero and $n-1$.
#+end_src
#+begin_src go <<Bootstrap indexes, Ch.~\ref{ch:dna}>>=
  for j := 0; j < n; j++ {
	  ind[j] = ran.Intn(n)
  }
#+end_src
#+begin_src latex
  The function \texttt{distMat} fills the distance matrix by first
  counting the transitions and transversions and then entering the
  actual distances.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:dna}>>=
  func distMat(dm [][]cell, msa [][]byte, pol []bool,
	  ind []int, optR, optU, optK bool,
	  ts util.TransitionTab) {
	  m := len(msa)
	  n := len(msa[0])
	  //<<Count transitions and transversions, Ch.~\ref{ch:dna}>>
	  //<<Enter distances, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  The count of transitions and transversions is restricted to the
  polymorphic columns.
#+end_src
#+begin_src go <<Count transitions and transversions, Ch.~\ref{ch:dna}>>=
  for i := 0; i < n; i++ {
	  if pol[ind[i]] {
		  //<<Analyze column, Ch.~\ref{ch:dna}>>
	  }
  }
#+end_src
#+begin_src latex
  In a given column, all pairwise comparisons between residues are made.
#+end_src
#+begin_src go <<Analyze column, Ch.~\ref{ch:dna}>>=
  for j := 0; j < m-1; j++ {
	  c1 := msa[j][i]
	  for k := j + 1; k < m; k++ {
		  c2 := msa[k][i]
		  if c1 != c2 {
			  if ts.IsTransition(c1, c2) {
				  dm[j][k].a++
			  } else {
				  dm[j][k].b++
			  }
		  }
	  }
  }
#+end_src
#+begin_src latex
  For each distance, we compute $\alpha$ and $\beta$, choose its type,
  and mirror the result in the distance matrix.
#+end_src
#+begin_src go <<Enter distances, Ch.~\ref{ch:dna}>>=
  for i := 0; i < m-1; i++ {
	  for j := i+1; j < m; j++ {
		  a := float64(dm[i][j].a) / float64(n)
		  b := float64(dm[i][j].b) / float64(n)
		  //<<Choose distance type, Ch.~\ref{ch:dna}>>
		  dm[j][i].d = dm[i][j].d
	  }
  }
#+end_src
#+begin_src latex
  Kimura distances are given by equation~(\ref{eq:kim}), Jukes-Cantor
  distances by equation~(\ref{eq:jc}).
#+end_src
#+begin_src go <<Choose distance type, Ch.~\ref{ch:dna}>>=
  if optR {
	  dm[i][j].d = float64(dm[i][j].a + dm[i][j].b)
  } else if optU {
	  dm[i][j].d = a + b
  } else if optK {
	  dm[i][j].d = -math.Log((1-2*a-b) * math.Sqrt(1-2*b)) / 2
  } else {
	  p := a + b
	  dm[i][j].d = -0.75 * math.Log(1 - 4./3. * p)
  }
#+end_src
#+begin_src latex
  We import \texttt{math}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "math"
#+end_src
#+begin_src latex
  We print the distance matrix in the format used by the phylogeny
  package PHYLIP~\cite{fel05:phy}, a de facto standard in the field. A
  PHYLIP distance matrix consists of the sample size in the first line,
  followed by the matrix consisting of the taxon name followed by the
  distances. We use a \texttt{tabprinter} to line up columns.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:dna}>>=
  func printDist(dm [][]cell, sa []*fasta.Sequence) {
	  //<<Print sample size, Ch.~\ref{ch:dna}>>
	  //<<Construct \texttt{tabwriter}, Ch.~\ref{ch:dna}>>
	  //<<Print distances, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  The sample size is the length of the distance matrix.
#+end_src
#+begin_src go <<Print sample size, Ch.~\ref{ch:dna}>>=
  n := len(dm)
  fmt.Printf("%d\n", n)
#+end_src
#+begin_src latex
  The \texttt{tabwriter} writes to a byte-buffer. We initialize the
  writer to a minimal cell width of 1, the width of the tab characters
  to zero, and add a single blank for padding.
#+end_src
#+begin_src go <<Construct \texttt{tabwriter}, Ch.~\ref{ch:dna}>>=
  var buf []byte
  buffer := bytes.NewBuffer(buf)
  w := new(tabwriter.Writer)
  w.Init(buffer, 1, 0, 1, ' ', 0)
#+end_src
#+begin_src latex
  We import \texttt{tabwriter}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:dna}>>=
  "text/tabwriter"
#+end_src
#+begin_src latex
  The distances are printed in a loop over all entries in the matrix. It
  turns out that a zero result can be \emph{negative} zero, which looks
  awkward in the printout so we check for it. Then we flush the
  \texttt{tabwriter} and print the buffer.
#+end_src
#+begin_src go <<Print distances, Ch.~\ref{ch:dna}>>=
  for i := 0; i < n; i++ {
	  fmt.Fprintf(w, "%s\t", sa[i].Header())
	  for j := 0; j < n; j++ {
		  //<<Check for negative zeros, Ch.~\ref{ch:dna}>>
	  }
	  fmt.Fprintf(w, "\n")
  }
  w.Flush()
  fmt.Printf("%s", buffer)
#+end_src
#+begin_src latex
  Negative zeros are discovered using the \texttt{Signbit} library
  function. If we find a negative zero, we print a positive zero
  instead.
#+end_src
#+begin_src go <<Check for negative zeros, Ch.~\ref{ch:dna}>>=
  if math.Signbit(dm[i][j].d) {
	  fmt.Fprintf(w, "%.6g\t", 0.0)
  } else {
	  fmt.Fprintf(w, "%.6g\t", dm[i][j].d)
  }
#+end_src
#+begin_src latex
  After printing, the distance matrix are reset.
#+end_src
#+begin_src go <<Reset distance matrix, Ch.~\ref{ch:dna}>>=
  for i := 0; i < m-1; i++ {
	  for j := i + 1; j < m; j++ {
		  dm[i][j].a = 0
		  dm[i][j].b = 0
	  }
  }
#+end_src
#+begin_src latex
  If no bootstrapping is requested, the index array is just filled
  $0,1,...,n-1$. 
#+end_src
#+begin_src go <<Without bootstrap, Ch.~\ref{ch:dna}>>=
  for i, _ := range ind {
	  ind[i] = i
  }
  distMat(dm, msa, pol, ind, optR, optU, optK, ts)
  printDist(dm, sa)
#+end_src
#+begin_src latex
  Our program is finished, let's test.
  \section*{Testing}
  The outline of the testing program contains hooks for imports and the
  code for driving the tests.
#+end_src
#+begin_src go <<dnaDist_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:dna}>>
  )
  func TestDnaDist(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:dna}>>
  }
#+end_src
#+begin_src latex
  We construct a table of test commands, a table of files with results,
  and then run the commands.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:dna}>>=
  tests := make([]*exec.Cmd, 0)
  //<<Construct test commands, Ch.~\ref{ch:dna}>>
  //<<Construct result files, Ch.~\ref{ch:dna}>>
  for i, c := range tests {
	  //<<Conduct test, Ch.~\ref{ch:dna}>>
  }

#+end_src
#+begin_src latex
  We import \texttt{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:dna}>>=
  "os/exec"
#+end_src
#+begin_src latex
  Testing is done on two data sets, the artificial \texttt{test.fa} and
  a small sample of primate mitochondrial DNA, \texttt{pr.fa}.
#+end_src
#+begin_src go <<Construct test commands, Ch.~\ref{ch:dna}>>=
  c := exec.Command("./dnaDist", "test.fa")
  tests = append(tests, c)
  c = exec.Command("./dnaDist", "-k", "test.fa")
  tests = append(tests, c)
  c = exec.Command("./dnaDist", "pr.fa")
  tests = append(tests, c)
  c = exec.Command("./dnaDist", "-k", "pr.fa")
  tests = append(tests, c)
  c = exec.Command("./dnaDist", "-b", "5", "-s", "3", "pr.fa")
  tests = append(tests, c)
#+end_src
#+begin_src latex
  The results we want are contained in five files.
#+end_src
#+begin_src go <<Construct result files, Ch.~\ref{ch:dna}>>=
  results := make([]string, len(tests))
  for i, _ := range tests {
	  results[i] = "r" + strconv.Itoa(i+1) + ".txt"
  }
#+end_src
#+begin_src latex
  We import \texttt{strconv}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:dna}>>=
  "strconv"
#+end_src
#+begin_src latex
  Now we run the tests and compare what we get with what we want.
#+end_src
#+begin_src go <<Conduct test, Ch.~\ref{ch:dna}>>=
  get, err := c.Output()
  if err != nil {
	  t.Errorf("couldn't run %q\n", c)
  }
  want, err := ioutil.ReadFile(results[i])
  if err != nil {
	  t.Errorf("couldn't open %q\n", results[i])
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src latex
  We import \texttt{ioutil} and bytes.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:dna}>>=
  "io/ioutil"
  "bytes"
#+end_src
