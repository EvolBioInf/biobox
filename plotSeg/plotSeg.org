#+begin_src latex
  x\section*{Introduction}
  Segment plots, also known as dot plots, display a potentially large
  number of exact matches between two sequences. Each exact match is a
  segment, which is denoted by a quartet of numbers $(x_1, y_1, x_2,
  y_2)$, where $(x_1,y_1)$ is the start of the segment and $(x_2,y_2)$
  its end. The program \ty{mumPlot} (Ch.~\ref{ch:m2p}) generates such
  quartets from MUMmer output. Figure~\ref{fig:ps}A shows some sample
  input data and Figure~\ref{fig:ps}B its plot generated with
  \ty{plotSeg}. Like the other \ty{plot*} programs, \ty{plotSeg} calls
  \ty{gnuplot}~\cite{jan10:gnu} for rendering.

  \begin{figure}
    \begin{center}
      \begin{tabular}{cc}
	\textbf{A} & \textbf{B}\\
	\raisebox{4cm}{
	\begin{tabular}{cccc}
	  1 & 1 & 57 & 57\\
	  65 & 65 & 229 & 229\\
	  214 & 226 & 235 & 247\\
	  226 & 244 & 309 & 327\\
	  303 & 320 & 392 & 409
	\end{tabular}
	}
	&
	\scalebox{0.95}{\includegraphics{plotSeg}}
      \end{tabular}
    \end{center}
    \caption{Example data (\textbf{A}) plotted with \ty{plotSeg}
      (\textbf{B}).}\label{fig:ps}
  \end{figure}

  \section*{Implementation}
  The outline of \ty{plotSeg} contains hooks for imports, types,
  functions, and the logic of the main function.
#+end_src
#+begin_src go <<plotSeg.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:ps}>>
  )

  //<<Types, Ch.~\ref{ch:ps}>>
  //<<Functions, Ch.~\ref{ch:ps}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:ps}>>
  }
#+end_src
#+begin_src latex
  In the main function we set the usage, declare the options, parse the
  options, and parse the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:ps}>>=
  //<<Set usage, Ch.~\ref{ch:ps}>>
  //<<Declare options, Ch.~\ref{ch:ps}>>
  //<<Parse options, Ch.~\ref{ch:ps}>>
  //<<Parse input files, Ch.~\ref{ch:ps}>>
#+end_src
#+begin_src latex
  The usage consists of the actual usage message, an explanation of the
  program's purpose, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:ps}>>=
  u := "plotSeg [-h] [option]... [foo.dat]..."
  p := "Generate segment plots, also known as dot plots."
  e := "mum2plot eco_x_y.mum | plotSeg -S 7.5cm7.5cm"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the obligatory version option, we declare options for the
  axes, and the graphics device.
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:ps}>>=
  var optV = flag.Bool("v", false, "version")
  //<<Declare axis options, Ch.~\ref{ch:ps}>>
  //<<Declare device options, Ch.~\ref{ch:ps}>>
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "flag"
#+end_src
#+begin_src latex
  The user can label the axes and set their ranges.
#+end_src
#+begin_src go <<Declare axis options, Ch.~\ref{ch:ps}>>=
  var optX = flag.String("x", "", "x-label")
  var optY = flag.String("y", "", "y-label")
  var optXX = flag.String("X", "s:e", "x-range")
  var optYY = flag.String("Y", "s:e", "y-range")
#+end_src
#+begin_src latex
  Instead of showing the plot in a window, the user can opt for an
  encapsulated postscript file and set its size. The user can also ask
  for the \ty{gnuplot} script of the plot.
#+end_src
#+begin_src go <<Declare device options, Ch.~\ref{ch:ps}>>=
  var optP = flag.String("p", "", "encapsulated postscript file")
  var optSS = flag.String("S", "x,y", "size of postscript plot " +
	  "in inch or cm")
  var optS = flag.String("s", "", "write R script to file")
#+end_src
#+begin_src latex
  We parse the options and respond to a request for the version first
  (\ty{-v}), as this terminates the program. Then we declare the
  variable \ty{opts} for holding the options and collect their values.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:ps}>>=
  flag.Parse()
  //<<Respond to \ty{-v}, Ch.~\ref{ch:ps}>>
  opts := new(Options)
  //<<Collect option values, Ch.~\ref{ch:ps}>>
#+end_src
#+begin_src latex
  We respond to \ty{-v} by printing a standardized message.
#+end_src
#+begin_src go <<Respond to \ty{-v}, Ch.~\ref{ch:ps}>>=
  if *optV {
	  util.PrintInfo("plotSeg")
  }
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_src latex
  We declare the type for holding the options and fill it with fields as
  we go along.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:ps}>>=
  type Options struct {
	  //<<\ty{Options} fields, Ch.~\ref{ch:ps}>>
  }
#+end_src
#+begin_src latex
  We collect the axis labels, axis ranges, plot size, and the graphics
  window. This is wxt by default, but if we are running on the macOS
  command line, we switch to qt. We also collect the names of the files
  for postscript and R output.
#+end_src
#+begin_src go <<Collect option values, Ch.~\ref{ch:ps}>>=
  opts.Xlab = *optX
  opts.Ylab = *optY
  opts.Xrange = *optXX
  opts.Yrange = *optYY
  opts.Size = *optSS
  opts.Win = "wxt"
  if runtime.GOOS == "darwin" { opts.Win = "qt" }
  opts.Ps = *optP
  opts.Script = *optS
#+end_src
#+begin_src latex
  We import \ty{runtime}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "runtime"
#+end_src
#+begin_src latex
  We add the fields we just used to \ty{Options}.
#+end_src
#+begin_src go <<\ty{Options} fields, Ch.~\ref{ch:ps}>>=
  Xlab, Ylab, Xrange, Yrange, Size string
  Width, Height float64
  Win, Ps, Script string
#+end_src
#+begin_src latex
  The remaining tokens on the command line are taken as input
  files. Each of them serves as input to a \ty{gnuplot} command that
  runs the same \ty{gnuplot} script. So we construct the script and the
  command and pass the command as an argument to the function
  \ty{scan}. This function is run for each input file. When we're done
  with the script, we delete it, unless the user asked for it.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:ps}>>=
  files := flag.Args()
  gscr := ""
  var gcmd *exec.Cmd
  //<<Construct script, Ch.~\ref{ch:ps}>>
  //<<Construct command, Ch.~\ref{ch:ps}>>
  clio.ParseFiles(files, scan, gcmd)
  if opts.Script == "" {
	  err = os.Remove(gscr)
	  if err != nil { log.Fatalf("can't delete %q", gscr) }
  }
#+end_src
#+begin_src latex
  We import \ty{exec} and \ty{os}, and \ty{log}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "os/exec"
  "os"
  "log"
#+end_src
#+begin_src latex
  We open a file, write the script to it, and close it again.
#+end_src
#+begin_src go <<Construct script, Ch.~\ref{ch:ps}>>=
  var script *os.File
  //<<Open script file, Ch.~\ref{ch:ps}>>
  //<<Write script to file, Ch.~\ref{ch:ps}>>
  script.Close()
#+end_src
#+begin_src latex
  If the user requested the script, we write to that, otherwise we
  write to a unique file generated by the system.
#+end_src
#+begin_src go <<Open script file, Ch.~\ref{ch:ps}>>=
  var err error
  if opts.Script == "" {
	  script, err = ioutil.TempFile("", "tmp_*.gp")
  } else {
	  script, err = os.Create(opts.Script)
  }
  if err != nil {
	  log.Fatal("can't open R-script")
  }
  gscr = script.Name()
#+end_src
#+begin_src latex
  We import \ty{ioutil}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "io/ioutil"
#+end_src
#+begin_src latex
  We write the script with a template. If the user just asked for the
  script, we quit at this point.
#+end_src
#+begin_src go <<Write script to file, Ch.~\ref{ch:ps}>>=
  //<<Write terminal, Ch.~\ref{ch:ps}>>
  //<<Write axes, Ch.~\ref{ch:ps}>>
  //<<Write plot, Ch.~\ref{ch:ps}>>
#+end_src
#+begin_src latex
  The terminal is either encapsulates postscript or a window. If it is a
  window, that window is persistent. If the user set the size of the
  postscript plot, we pass that on.
#+end_src
#+begin_src go <<Write terminal, Ch.~\ref{ch:ps}>>=
  t := "set terminal"
  if opts.Ps != "" {
	  t += " eps color"
  } else {
	  t += " " + opts.Win + " persist"
  }
  if opts.Size[0] != 'x' && opts.Ps != "" {
	  t += " size " + opts.Size
  }
  fmt.Fprintf(script, "%s\n", t)
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "fmt"
#+end_src
#+begin_src latex
  If the terminal is postscript, we also set the output file.
#+end_src
#+begin_src go <<Write terminal, Ch.~\ref{ch:ps}>>=
  if opts.Ps != "" {
	  fmt.Fprintf(script, "set output \"%s\"\n", opts.Ps)
  }
#+end_src
#+begin_src latex
  We label the x-axis and the y-axis.
#+end_src
#+begin_src go <<Write axes, Ch.~\ref{ch:ps}>>=
  if opts.Xlab != "" {
	  fmt.Fprintf(script, "set xlabel \"%s\"\n", opts.Xlab)
  }
  if opts.Ylab != "" {
	  fmt.Fprintf(script, "set ylabel \"%s\"\n", opts.Ylab)
  }
#+end_src
#+begin_src latex
  We write the plot as an untitled line plot with ranges. The data is
  read from standard in.
#+end_src
#+begin_src go <<Write plot, Ch.~\ref{ch:ps}>>=
  xr := ""
  yr := ""
  if opts.Xrange[0] != 's' { xr = opts.Xrange }
  if opts.Yrange[0] != 's' { yr = opts.Yrange }
  fmt.Fprintf(script, "plot[%s][%s] \"< cat\" t '' w l\n", xr, yr)
#+end_src
#+begin_src latex
  The script is written, so we run it.
#+end_src
#+begin_src go <<Construct command, Ch.~\ref{ch:ps}>>=
  gcmd = exec.Command("gnuplot", gscr)
#+end_src
#+begin_src latex
  Inside \ty{scan}, we retrieve the command we just constructed by type
  assertion, get the data, pipe the data into the command, and run it.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:ps}>>=
  func scan(r io.Reader, args ...interface{}) {
	  gcmd := args[0].(*exec.Cmd)
	  //<<Read data, Ch.~\ref{ch:ps}>>
	  //<<Pipe data into command, Ch.~\ref{ch:ps}>>
	  //<<Run command, Ch.~\ref{ch:ps}>>
  }
#+end_src
#+begin_src latex
  We import \ty{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "io"
#+end_src
#+begin_src latex
  We read the data, skip comments, and check each data line has four
  columns. If not, something has gone wrong and we bail.
#+end_src
#+begin_src go <<Read data, Ch.~\ref{ch:ps}>>=
  sc := bufio.NewScanner(r)
  var data [][]string
  for sc.Scan() {
	  row := sc.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Fields(row)
	  l := len(fields)
	  if l != 4 {
		  log.Fatalf("get %d columns, want 4\n", l)
	  }
	  data = append(data, fields)
  }
#+end_src
#+begin_src latex
  We import \ty{bufio} and \ty{strings}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:ps}>>=
  "bufio"
  "strings"
#+end_src
#+begin_src latex
  Piping the data into the command is wrapped in a goroutine. The
  routine signals it is finished via a channel. The data is written as
  two points separated by a blank. This is interpreted by \ty{gnuplot}
  as a line that is disconnected from the next line.
#+end_src
#+begin_src go <<Pipe data into command, Ch.~\ref{ch:ps}>>=
  stdin, err := gcmd.StdinPipe()
  if err != nil { log.Fatal("can't open stdin") }
  done := make(chan struct{})
  go func() {
	  for _, d := range data {
		  fmt.Fprintln(stdin, d[0], d[1])
		  fmt.Fprintln(stdin, d[2], d[3])
		  fmt.Fprintln(stdin)
	  }
	  stdin.Close()
	  done <- struct{}{}
  }()
#+end_src
#+begin_src latex
  We run the command and signal we're done before moving on to delete
  the script.
#+end_src
#+begin_src go <<Run command, Ch.~\ref{ch:ps}>>=
  if len(data) > 0 {
	  err = gcmd.Run()
	  if err != nil {
		  log.Fatalf("can't run %q", gcmd)
	  }
  }
  <-done
#+end_src
#+begin_src latex
  The program \ty{plotSeg} is finished, let's test it.
  \section*{Testing}
  Our testing program contains hooks for imports and the testing logic.
#+end_src
#+begin_src go <<plotSeg_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:ps}>>
  )

  func TestPlotSeg(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:ps}>>
  }
#+end_src
#+begin_src latex
  We test by writing the individual tests and running them in a
  loop. Each test is written to the same unique \ty{gnuplot} file, which
  we remove again after the tests.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:ps}>>=
  gf, err := ioutil.TempFile(".", "tmp_*.gp")
  if err != nil { log.Fatal("cant open output file") }
  g := gf.Name()
  var tests []*exec.Cmd
  //<<Construct tests, Ch.~\ref{ch:ps}>>
  for i, test := range tests {
	  //<<Run test, Ch.~\ref{ch:ps}>>
  }
  err = os.Remove(g)
  if err != nil { log.Fatalf("can't delete %q", g) }
#+end_src
#+begin_src latex
  We import \ty{ioutil}, \ty{log}, \ty{exec}, and \ty{os}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:ps}>>=
  "io/ioutil"
  "log"
  "os/exec"
  "os"
#+end_src
#+begin_src latex
  We test setting axis labels, ranges, and plot size.
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:ps}>>=
  //<<Test axis labels, Ch.~\ref{ch:ps}>>
  //<<Test axis ranges, Ch.~\ref{ch:ps}>>
  //<<Test plot size, Ch.~\ref{ch:ps}>>
#+end_src
#+begin_src latex
  We begin by running \ty{plotSeg} on the example data in \ty{test.dat}
  without any other options. Then we set the x-label, the y-label, and
  both.
#+end_src
#+begin_src go <<Test axis labels, Ch.~\ref{ch:ps}>>=
  f := "test.dat"
  te := exec.Command("./plotSeg", "-s", g, f)
  tests = append(tests, te)
  te = exec.Command("./plotSeg", "-s", g, "-x", "x", f)
  tests = append(tests, te)
  te = exec.Command("./plotSeg", "-s", g, "-y", "y", f)
  tests = append(tests, te)
  te = exec.Command("./plotSeg", "-s", g, "-x", "x",
	  "-y", "y", f)
  tests = append(tests, te)
#+end_src
#+begin_src latex
  We set the x-range, the y-range, and both.
#+end_src
#+begin_src go <<Test axis ranges, Ch.~\ref{ch:ps}>>=
  te = exec.Command("./plotSeg", "-s", g, "-X", "100:500", f)
  tests = append(tests, te)
  te = exec.Command("./plotSeg", "-s", g, "-Y", "100:500", f)
  tests = append(tests, te)
  te = exec.Command("./plotSeg", "-s", g, "-X", "100:500",
	  "-Y", "100:500", f)
  tests = append(tests, te)
#+end_src
#+begin_src latex
  We set the plot size.
#+end_src
#+begin_src go <<Test plot size, Ch.~\ref{ch:ps}>>=
  te = exec.Command("./plotSeg", "-s", g, "-S", "5,6", f)
  tests = append(tests, te)
#+end_src
#+begin_src latex
  For each test we compare what we get with what we want, which is
  stored in a file the name of which we still need to construct.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:ps}>>=
  err = test.Run()
  if err != nil { log.Fatalf("can't run %q", test) }
  get, err := ioutil.ReadFile(g)
  if err != nil { log.Fatalf("can't read %q", g) }
  //<<Construct file name, Ch.~\ref{ch:ps}>>
  want, err := ioutil.ReadFile(f)
  if err != nil { log.Fatalf("can't read %q", f) }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n",
		  string(get), string(want))
  }
#+end_src
#+begin_src latex
  We import \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:ps}>>=
  "bytes"
#+end_src
#+begin_src latex
  On default systems, the results we want are stored in files
  \ty{results/r1.gp}, \ty{results/r2.gp}, and so on. On darwin systems,
  the names are extended by ``d''.
#+end_src
#+begin_src go <<Construct file name, Ch.~\ref{ch:ps}>>=
  f = "results/r" + strconv.Itoa(i+1)
  if runtime.GOOS == "darwin" {
	  f += "d"
  }
  f += ".gp"
#+end_src
#+begin_src latex
  We import \ty{strconv} and \ty{runtime}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:ps}>>=
  "strconv"
  "runtime"
#+end_src

