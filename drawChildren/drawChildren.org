#+begin_export latex
\section*{Introduction}
The program \ty{drawChildren} takes as input the output of
\ty{pickChildren} in Chapter~\ref{ch:pc}. This consists of tree nodes
written as triplets $(p, c_1, c_2)$, where $p$ is the parent, $c_1$
and $c_2$ its two children. Figure~\ref{fig:dc}A shows an example.
\begin{figure}[hb]
  \begin{center}
    \begin{tabular}{cc}
      \textbf{A} & \textbf{B}\\
      \raisebox{1cm}{
        \begin{tabular}{lll}
          \hline
          $p$ & $c_1$ & $c_2$\\\hline
          5 & 2 & 1\\
          6 & 3 & 2\\
          7 & 1 & 1\\\hline
        \end{tabular}
      }
      &
      \scalebox{0.3}{\includegraphics{../drawChildren/example}}
    \end{tabular}
  \end{center}
  \caption{Example input for \ty{dawChildren} (\textbf{A}) and the
    corresponding output (\textbf{B}).}\label{fig:dc}
\end{figure}

The pairs of children from these triplets are used to construct a
coalescent tree according to Algorithm~\ref{alg:chi}. This is a
variant on Algorithm~\ref{alg:coa} used to construct the coalescent
tree in \ty{pickChildren}. Figure~\ref{fig:dc}B shows the tree
constructed by \ty{draw\-Chil\-dren} from the input on the left. The tree
is written in the dot notation, which can be visualized using the
program \ty{dot} available as part of the free graphviz package.

\begin{algorithm}[hb]
\caption{Reconstructing coalescent from output of \ty{pickChildren}.}\label{alg:chi}
\input{../drawChildren/algTree}
\end{algorithm}

\section*{Implementation}
The outline of \ty{drawChildren} has hooks for imports, types,
functions, and the logic of the main function.
#+end_export
#+begin_src go <<drawChildren.go>>=
  package main

  import (
	  //<<Imports, Ch. \ref{ch:dc}>>
  )

  //<<Types, Ch. \ref{ch:dc}>>
  //<<Functions, Ch. \ref{ch:dc}>>
  func main() {
	  //<<Main function, Ch. \ref{ch:dc}>>
  }
#+end_src
#+begin_export latex
In the main function we prepare the \ty{log} package for errors from
\ty{drawChildren}, set the usage, declare the options, parse the
options, and parse the input files.
#+end_export
#+begin_src go <<Main function, Ch. \ref{ch:dc}>>=
  util.PrepLog("drawChildren")
  //<<Set usage, Ch. \ref{ch:dc}>>
  //<<Declare options, Ch. \ref{ch:dc}>>
  //<<Parse options, Ch. \ref{ch:dc}>>
  //<<Parse input files, Ch. \ref{ch:dc}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:dc}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_export latex
The usage consists of three parts, the actual usage message, an
explanation of the purpose of \ty{drawChildren}, and an example
command.
#+end_export
#+begin_src go <<Set usage, Ch. \ref{ch:dc}>>=
  u := "drawChildren [-h] [option] [foo.txt]..."
  p := "Draw the coalescent implied by the output of " +
	  "pickChildren."
  e := "pickChildren | tee pc.out | drawChildren | dot -T x11 &"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:dc}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
There are no options to declare apart from the version, \ty{-v}.
#+end_export
#+begin_src go <<Declare options, Ch. \ref{ch:dc}>>=
  optV := flag.Bool("v", false, "version")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:dc}>>=
  "flag"
#+end_src
#+begin_export latex
We parse the options and respond to a request for the version by
printing the information on \ty{drawChildren}, which contains the
version.
#+end_export
#+begin_src go <<Parse options, Ch. \ref{ch:dc}>>=
  flag.Parse()
  if *optV {
	  util.PrintInfo("drawChildren")
  }
#+end_src
#+begin_export latex
The remaining tokens on the command line are taken to be the names of
input files. We call \ty{ParseFiles} to apply the function \ty{parse}
to each file. We'll write \ty{parse} in a moment.
#+end_export
#+begin_src go <<Parse input files, Ch. \ref{ch:dc}>>=
  files := flag.Args()
  clio.ParseFiles(files, parse)
#+end_src
#+begin_export latex
Inside \ty{parse} we declare a slice of the pairs of child indexes as
explained in the Introduction, read the pairs, construct the
coalescent from them, and print it.
#+end_export
#+begin_src go <<Functions, Ch. \ref{ch:dc}>>=
  func parse(r io.Reader, args ...interface{}) {
	  pairs := []Pair{}
	  //<<Read pairs of children, Ch. \ref{ch:dc}>>
	  //<<Construct coalescent, Ch. \ref{ch:dc}>>
	  //<<Print coalescent, Ch. \ref{ch:dc}>>
  }
#+end_src
#+begin_export latex
We import \ty{io}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:dc}>>=
  "io"
#+end_src
#+begin_export latex
We declare a \ty{Pair} as a \ty{struct} with fields for two children,
\ty{c1} and \ty{c2}.
#+end_export
#+begin_src go <<Types, Ch. \ref{ch:dc}>>=
  type Pair struct {
	  c1, c2 int
  }
#+end_src
#+begin_export latex
To read the pairs of children, we scan the input file. This contains
two kinds of lines, headers and data. We deal with both.
#+end_export
#+begin_src go <<Read pairs of children, Ch. \ref{ch:dc}>>=
  sc := bufio.NewScanner(r)
  for sc.Scan() {
	  //<<Deal with header, Ch. \ref{ch:dc}>>
	  //<<Deal with data, Ch. \ref{ch:dc}>>
  }
#+end_src
#+begin_export latex
We import \ty{bufio}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:dc}>>=
  "bufio"
#+end_src
#+begin_export latex
A header is marked by a leading hash tag, and we simply skip it.
#+end_export
#+begin_src go <<Deal with header, Ch. \ref{ch:dc}>>=
  line := sc.Text()
  if line[0] == '#' {
	  continue
  }
#+end_src
#+begin_export latex
Data lines are split into the three tokes they contain. From these
tokes we construct the pair of children and store it. The children are
one-based in the input, so we convert them to zero-based for internal
consumption.
#+end_export
#+begin_src go <<Deal with data, Ch. \ref{ch:dc}>>=
  fields := strings.Fields(line)
  c1, err := strconv.Atoi(fields[1])
  if err != nil {
	  log.Fatal(err)
  }
  c2, err := strconv.Atoi(fields[2])
  if err != nil {
	  log.Fatal(err)
  }
  pair := Pair{c1-1, c2-1}
  pairs = append(pairs, pair)
#+end_src
#+begin_export latex
We import \ty{strings} and \ty{strconv}, and \ty{log}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:dc}>>=
  "strings"
  "strconv"
  "log"
#+end_src
#+begin_export latex
A tree consists of nodes. In our case a node has an identifier and
holds pointers to its two children.
#+end_export
#+begin_src go <<Types, Ch. \ref{ch:dc}>>=
  type Node struct {
	  id int
	  child1, child2 *Node
  }
#+end_src
#+begin_export latex
To construct the coalescent, we first allocate nodes for the tree,
then construct its toplogy.
#+end_export
#+begin_src go <<Construct coalescent, Ch. \ref{ch:dc}>>=
  //<<Allocate tree, Ch. \ref{ch:dc}>>
  //<<Construct topology, Ch. \ref{ch:dc}>>
#+end_src
#+begin_export latex
There are $n-1$ internal nodes in a binary tree, hence we have now
read $n-1$ pairs of children. So we allocate $2n-1$ nodes and set
their identifiers to their position in the slice.
#+end_export
#+begin_src go <<Allocate tree, Ch. \ref{ch:dc}>>=
  n := len(pairs) + 1
  tree := make([]*Node, 2 * n - 1)
  for i := 0; i < 2*n-1; i++ {
	  tree[i] = new(Node)
	  tree[i].id = i
  }
#+end_src
#+begin_export latex
We follow algorithm~\ref{alg:chi} to construct the coalescent guided
by the pairs of children we have read.
#+end_export
#+begin_src go <<Construct topology, Ch. \ref{ch:dc}>>=
  for i := n; i > 1; i = i-1 {
	  p := 2 * n - i
	  c := pairs[p-n].c1
	  tree[p].child1 = tree[c]
	  tree[c] = tree[i-1]
	  c = pairs[p-n].c2
	  tree[p].child2 = tree[c]
	  tree[c] = tree[p]
  }
#+end_src
#+begin_export latex
To print the coalescent, we print the header of the graph followed by
instructions to omit arrowheads. Then we iterate over the internal
nodes and print each one together with its children. At the end we
close the graph.
#+end_export
#+begin_src go <<Print coalescent, Ch. \ref{ch:dc}>>=
  fmt.Println("digraph g {")
  fmt.Println("\tedge [arrowhead=\"none\"]")
  for i := n; i < 2*n-1; i++ {
	  p := tree[i].id
	  c1 := tree[i].child1.id
	  c2 := tree[i].child2.id
	  fmt.Printf("\t%d -> %d\n", p+1, c1+1)
	  fmt.Printf("\t%d -> %d\n", p+1, c2+1)
  }
  fmt.Println("}")
#+end_src
#+begin_export latex
We import \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:dc}>>=
  "fmt"
#+end_src
#+begin_export latex
We have finished \ty{drawChildren}, time to test it.

\section*{Testing}
The outline of our testing code has hooks for imports and the testing
logic itself.
#+end_export
#+begin_src go <<drawChildren_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch. \ref{ch:dc}>>
  )

  func TestDrawChildren(t *testing.T) {
	  //<<Testing, Ch. \ref{ch:dc}>>
  }
#+end_src
#+begin_export latex
We construct a single test and run it.
#+end_export
#+begin_src go <<Testing, Ch. \ref{ch:dc}>>=
  //<<Construct test, Ch. \ref{ch:dc}>>
  //<<Run test, Ch. \ref{ch:dc}>>
#+end_src
#+begin_export latex
We construct a test with input contained in \ty{test.txt}.
#+end_export
#+begin_src go <<Construct test, Ch. \ref{ch:dc}>>=
  test := exec.Command("./drawChildren", "test.txt")
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:dc}>>=
  "os/exec"
#+end_src
#+begin_export latex
We run the test and compare the result we get to the result we want
contained in \ty{r.txt}.
#+end_export
#+begin_src go <<Run test, Ch. \ref{ch:dc}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
  want, err := os.ReadFile("r.txt")
  if err != nil {
	  t.Errorf("couldn't open %q", "r.txt")
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{os} and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:dc}>>=
  "os"
  "bytes"
#+end_src

