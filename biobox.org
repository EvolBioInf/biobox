#+begin_src latex
  Our aim is to count all characters, or residues, in a FASTA file.
#+end_src
#+begin_src go <<cchar.go>>=
  package main

  import (
  //<<Imports, Ch.~\ref{ch:cch}>>
  )

  //<<Variables, Ch.~\ref{ch:cch}>>
  //<<Functions, Ch.~\ref{ch:cch}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:cch}>>
  }
#+end_src
#+begin_src latex
  In the \texttt{main} function we first parse the options set by the
  user and then iterate over the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:cch}>>=
  //<<Parse options, Ch.~\ref{ch:cch}>>
  //<<Iterate over files, Ch.~\ref{ch:cch}>>
#+end_src
#+begin_src latex
  The user can choose between reporting counts for each sequence
  separately or for all sequences combined. There is also the option to
  just print the version and some other information about the
  program.. So we declare the Boolean options \texttt{-s} and
  \texttt{-v}.
#+end_src
#+begin_src go <<Variables, Ch.~\ref{ch:cch}>>=
  var optS = flag.Bool("s", false, "count sequences separately")
  var optV = flag.Bool("v", false, "print version & program information")
#+end_src
#+begin_src latex
  This requires the \texttt{flag} package.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:cch}>>=
  "flag"
#+end_src
#+begin_src latex
  After parsing the flags, the remaining arguments are the input files.
#+end_src
#+begin_src go <<Interact with user, Ch.~\ref{ch:cch}>>=
  flag.Parse()
  if *optV {
	  version.Print(GitCommit, Date)
  }
  files := flag.Args()
#+end_src
#+begin_src latex
  We import the \texttt{version} package
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:cch}>>=
  "github.com/evolbioinf/version"
#+end_src
#+begin_src latex
  and declare the git commit and the date, which are set by \texttt{go
    build}.
#+end_src
#+begin_src go <<Variables, Ch.~\ref{ch:cch}>>=
  var GitCommit, Date string
#+end_src
#+begin_src latex
  If there are no input files, we read from the standard input.
#+end_src
#+begin_src go <<Iterate over files, Ch.~\ref{ch:cch}>>=
  r := os.Stdin
  if len(files) == 0 {
	  scan(r)
  } else {
	  for _, f := range files {
		  if r, err := os.Open(f); err != nil {
			  log.Fatalf("Couldn't open %q.\n", f)
		  }
		  scan(r)
		  os.Close(r)
	  }
  }
#+end_src
#+begin_src latex
  We need the packages \texttt{os}, and \texttt{log}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:cch}>>=
  "os"
  "log"
#+end_src
#+begin_src latex
  A file is scanned in three steps. Variables are prepared, the file is
  parsed, and the result of the parsing is processed.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:cch}>>=
  func scan(r io.Reader) {
	  //<<Prepare variables, Ch.~\ref{ch:cch}>>
	  //<<Parse file, Ch.~\ref{ch:cch}>>
	  //<<Process parsing, Ch.~\ref{ch:cch}>>
  }
#+end_src
#+begin_src latex
  When parsing a FASTA file, header lines indicate the start of the
  subsequent sequence data. With the exception of the first header, they
  also indicate the end of the previous sequence. So when encountering a
  header, we need to distinguish between the first and all subsequent
  headers. 
#+end_src
#+begin_src go <<Prepare variables, Ch.~\ref{ch:cch}>>=
  first := true
#+end_src
#+begin_src latex
  Residues are encoded as bytes, which are unsigned eight-bit
  integers. So they are best counted as indexes into a slice of
  $2^8=256$ large integers. 
#+end_src
#+begin_src go <<Prepare variables, Ch.~\ref{ch:cch}>>=
  counts := make([]int64, 256)
#+end_src
#+begin_src latex
  When we reach the end of a sequence, we print its residue counts if
  the user has set the \texttt{-s} option. In that case we need to refer
  to the last header read.
#+end_src
#+begin_src go <<Prepare variables, Ch.~\ref{ch:cch}>>=
  header := ""
#+end_src
#+begin_src latex
  FASTA files consist of lines of data. They are thus best read line by
  line, as implemented in the buffered scanner.
#+end_src
#+begin_src go <<Prepare variables, Ch.~\ref{ch:cch}>>=
scanner := bufio.NewScanner(r)
#+end_src
#+begin_src latex
  We haven't encountered the \texttt{bufio} package yet.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:cch}>>=
  "bufio"
#+end_src
#+begin_src latex
  When scanning, the input data is supplied as byte arrays. We
  distinguish between headers and data. When dealing with a header, we
  only do something, if counts are printed for each sequence separately.
#+end_src
#+begin_src go <<Parse file, Ch.~\ref{ch:cch}>>=
  for scanner.Scan() {
	  bytes := scanner.Bytes()
	  if bytes[0] = '>' {
		  if *optS {
			  //<<Deal with header, Ch.~\ref{ch:cch}>>
		  }
	  } else {
		  //<<Deal with data, Ch.~\ref{ch:cch}>>
	  }
  }
#+end_src
#+begin_src latex
  If we are dealing with the first header, we just toggle the
  \texttt{first} variable. Otherwise, we have reached the end of
  sequence. In this case we print the sequence's header, its residue
  counts, and reset these counts. At the end we store the header just
  encountered.
#+end_src
#+begin_src go <<Deal with header, Ch.~\ref{ch:cch}>>=
  if first {
	  first = false
  } else {
	  fmt.Printf(">%s: ", header)
	  write(counts)
	  reset(counts)
  }
  header = string(bytes[1:])
#+end_src
#+begin_src latex
  Import the \texttt{fmt} package.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:cch}>>=
  "fmt"
#+end_src
#+begin_src latex
  If not dealing with a header, we count the residues.
#+end_src
#+begin_src go <<Deal with data, Ch.~\ref{ch:cch}>>=
  for _, v := range bytes {
	  counts[v]++
  }
#+end_src
#+begin_src latex
  The function \texttt{write} prints the total number of residues read
  and their individual counts and frequencies.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:cch}>>=
  func write(counts []int64) {
	  //<<Print total residue count, Ch.~\ref{ch:cch}>>
	  //<<Print individual counts, Ch.~\ref{ch:cch}>>
  }
#+end_src
#+begin_src latex
  We sum the individual nucleotide counts and print them.
#+end_src
#+begin_src go <<Print total residue count, Ch.~\ref{ch:cch}>>=
  var s int64
  for _, v := range counts {
	  s += v
  }
  fmt.Printf("%d\n", s)
#+end_src
#+begin_src latex
  We print the individual residue counts and frequencies in a tab
  delimited table.
#+end_src
#+begin_src go <<Print individual counts, Ch.~\ref{ch:cch}>>=
  fmt.Printf("# Char\tCount\tFraction\n")
  for i, v := range counts {
	  if v > 0 {
		  fmt.Printf("%c\t%d\t%.6f\n", i, v, float64(v)/float64(s)}
	  }
  }
#+end_src
#+begin_src latex
  We reset the residue counts.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:cch}>>=
  func reset(counts []int64) {
	  for i, _ := range counts {
		  counts[i] = 0
	  }
  }
#+end_src
#+begin_src latex
  Having parsed the file, we deal either with the last sequence or the
  complete output.
#+end_src
#+begin_src go <<Process parsing, Ch.~\ref{ch:cch}>>=
  if *optS {
	  fmt.Printf(">%s: ", header)
  } else {
	  fmt.Printf("# Total number of input characters: ")
  }
  write(count)
#+end_src
