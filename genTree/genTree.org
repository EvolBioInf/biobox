#+begin_src latex
  \section*{Introduction}
  It is often handy to have a source of random phylogenies and
  \ty{genTree} prints random phylogenies in Newick format. An example is
  shown in Figure~\ref{fig:gt}A, which is drawn using \ty{plotTree} in
  Figure~\ref{fig:gt}B.
  \begin{figure}
    \begin{center}
      \begin{tabular}{cc}
	\textbf{A} & \textbf{B}\\
	\raisebox{2cm}{
	  \begin{minipage}{6cm}
	  \ty{(((T1:33,T2:37):5,(T3:45,T4:}
	  \ty{43):1):3,((T5:23,T6:30):17,(}
	  \ty{(T7:10,(T8:2,T9:9):5):24,T10}
	  \ty{:37):2):5):0;}
	  \end{minipage}
	  }
	&
	\scalebox{0.75}{\includegraphics{gt.ps}}
      \end{tabular}
      \caption{A random tree generated by \ty{genTree} in Newick format
	(\textbf{A}) and drawn with \ty{plotTree} (\textbf{B}).}\label{fig:gt}
    \end{center}
  \end{figure}
  \section*{Implementation}
  The outline of \ty{genTree} has hooks for imports, functions, and the
  logic of the main function.
#+end_src
#+begin_src go <<genTree.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:gt}>>
  )
  //<<Functions, Ch.~\ref{ch:gt}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:gt}>>
  }
#+end_src
#+begin_src latex
  In the main function, we prepare the \ty{log} package, set the usage,
  declare the options, parse the options, and compute the trees.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:gt}>>=
  util.PrepLog("genTree")
  //<<Set usage, Ch.~\ref{ch:gt}>>
  //<<Declare options, Ch.~\ref{ch:gt}>>
  //<<Parse options, Ch.~\ref{ch:gt}>>
  //<<Calculate trees, Ch.~\ref{ch:gt}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_src latex
  The usage consists of three parts. The actual usage message, an
  explanation of the program's purpose, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:gt}>>=
  u := "genTree [-h] [option]..."
  p := "Generate random trees."
  e := "genTree -n 15"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  We declare eight options:
  \begin{itemize}
  \item \ty{-n} sample size
  \item \ty{-i} number of iterations
  \item \ty{-t} mutation rate, $\theta=2N\mu$
  \item \ty{-c} coalescent instead of phylogeny
  \item \ty{-a} absolute branch lengths instead of number of mutations
  \item \ty{-l} label internal nodes in addition to leaves
  \item \ty{-s} seed for random number generator
  \item \ty{-v} version
  \end{itemize}
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:gt}>>=
  var optN = flag.Int("n", 10, "sample size")
  var optI = flag.Int("i", 1, "iterations")
  var optT = flag.Float64("t", 1000, "theta=2Nu")
  var optC = flag.Bool("c", false, "coalescent")
  var optA = flag.Bool("a", false, "absolute branch lengths")
  var optL = flag.Bool("l", false, "label internal branches")
  var optS = flag.Int("s", 0, "seed for random number generator")
  var optV = flag.Bool("v", false, "version")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "flag"
#+end_src
#+begin_src latex
  We parse the options and respond to \ty{-v} by printing program
  information. We also respond to \ty{-s} by seeding the random number
  generator. The seed is either given by the user or we take the current
  Unix time in nanoseconds.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:gt}>>=
  flag.Parse()
  if *optV {
	  util.PrintInfo("genTree")
  }
  seed := int64(*optS)
  if seed == 0 {
	  seed = time.Now().UnixNano()
  }
  ran := rand.New(rand.NewSource(seed))
#+end_src
#+begin_src latex
  We import \ty{time} and \ty{rand}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "time"
  "math/rand"
#+end_src
#+begin_src latex
  We represet a tree as a slice of nodes. For each iteration, we
  construct the tree, add mutations if desired, and print it.
#+end_src
#+begin_src go <<Calculate trees, Ch.~\ref{ch:gt}>>=
  n := *optN
  tree := make([]*nwk.Node, 2*n-1)
  for ii := 0; ii < *optI; ii++ {
	  //<<Construct tree, Ch.~\ref{ch:gt}>>
	  if !*optA {
		  //<<Add mutations, Ch.~\ref{ch:gt}>>
	  }
	  //<<Print tree, Ch.~\ref{ch:gt}>>
  }
#+end_src
#+begin_src latex
  We import \ty{nwk}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "github.com/evolbioinf/nwk"
#+end_src
#+begin_src latex
  A tree is constructed in four steps: We allocate the nodes, set their
  times, construct the topology, and determine the branch lengths.
#+end_src
#+begin_src go <<Construct tree, Ch.~\ref{ch:gt}>>=
  //<<Allocate nodes, Ch.~\ref{ch:gt}>>
  //<<Set node times, Ch.~\ref{ch:gt}>>
  //<<Construct topology, Ch.~\ref{ch:gt}>>
  //<<Determine branch lengths, Ch.~\ref{ch:gt}>>
#+end_src
#+begin_src latex
  We allocate the nodes by calling \ty{NewNode}.
#+end_src
#+begin_src go <<Allocate nodes, Ch.~\ref{ch:gt}>>=
  for i := 0; i < 2*n-1; i++ {
	  tree[i] = nwk.NewNode()
  }
#+end_src
#+begin_src latex
  Coalescence times are exponentially distributed with parameter
  ${i\choose 2}$, where $i$ is the number of lines. Their computation is
  summarized in Algorithm~\ref{alg:ca1}, which is adapted
  from~\cite{hud90:gen}. Curiously, the tree looks more like a phylogeny
  if we use the constant ${n\choose 2}$ as parameter instead of
  ${i\choose 2}$. We also note that the node actually has a branch
  length.
  \begin{algorithm}
    \caption{Generate node times in coalescent.}\label{alg:ca1}
    \input{algCoalTimes}
  \end{algorithm}
#+end_src
#+begin_src go <<Set node times, Ch.~\ref{ch:gt}>>=
  t := 0.0
  for i := 0; i < n; i++ { tree[i].HasLength = true }
  for i := n; i > 1; i-- {
	  lambda := float64(n * (n-1) / 2)
	  if *optC { lambda = float64(i * (i-1) / 2) }
	  t += rand.ExpFloat64() / lambda
	  j := 2 * n - i
	  tree[j].Length = t
	  tree[j].HasLength = true
  }
#+end_src
#+begin_src latex
  We generate the topology of the coalescent by going through the
  internal nodes and thinking of them as the current parent node. A
  parent, for which we pick two children~\cite{hud90:gen}.
#+end_src
#+begin_src go <<Construct topology, Ch.~\ref{ch:gt}>>=
  for i := n; i > 1; i-- {
	  p := tree[2 * n - i]
	  //<<Pick first child, Ch.~\ref{ch:gt}>>
	  //<<Pick second child, Ch.~ref{ch:gt}>>
  }
#+end_src
#+begin_src latex
  As detailed in Algorithm~\ref{alg:ca2}, we pick the first child from
  among the nodes in positions $0,...,i-1$ and replace it by node $i-1$.
  \begin{algorithm}
    \caption{Generate coalescent.}\label{alg:ca2}
    \input{algCoalTree}
  \end{algorithm}
#+end_src
#+begin_src go <<Pick first child, Ch.~\ref{ch:gt}>>=
  r := ran.Intn(i)
  c := tree[r]
  p.AddChild(c)
  tree[r] = tree[i-1]
#+end_src
#+begin_src latex
  We pick the second child and replace it by the current parent, which
  thus becomes a child candidate in the next round.
#+end_src
#+begin_src go <<Pick second child, Ch.~ref{ch:gt}>>=
  r = ran.Intn(i-1)
  c = tree[r]
  p.AddChild(c)
  tree[r] = p
#+end_src
#+begin_src latex
  The branch lengths are determined by traversing the tree from the
  root located in the last entry of the tree array.
#+end_src
#+begin_src go <<Determine branch lengths, Ch.~\ref{ch:gt}>>=
  root := tree[len(tree)-1]
  setBranchLen(root)
#+end_src
#+begin_src latex
  Inside \ty{setBranchLen} we determine the branch length as the
  difference between the current node position and that of its parent,
  starting from the leaves.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:gt}>>=
  func setBranchLen(v *nwk.Node) {
	  if v == nil { return }
	  setBranchLen(v.Child)
	  l := 0.0
	  if v.Parent != nil {
		  l = v.Parent.Length - v.Length
	  }
	  v.Length = l
	  setBranchLen(v.Sib)
  }
#+end_src
#+begin_src latex
  The number of mutations is a determined in another tree traversal
  conditioned on the population mutation rate, $\theta$. The number of
  mutations is a random variable, so the function also takes the random
  number generator as argument.
#+end_src
#+begin_src go <<Add mutations, Ch.~\ref{ch:gt}>>=
  addMut(root, *optT, ran)
#+end_src
#+begin_src latex
  Inside \ty{addMut}, we compute the number of mutations as a function
  of the branch length and $\theta$.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:gt}>>=
  func addMut(v *nwk.Node, t float64, r *rand.Rand) {
	  if v == nil { return }
	  //<<Calculate the number of mutations, Ch.~\ref{ch:gt}>>
	  addMut(v.Child, t, r)
	  addMut(v.Sib, t, r)
  }
#+end_src
#+begin_src latex
  The number of mutations is a Poisson-distributed random variable with
  mean $\lambda=\ell/2\theta$, where $\ell$ is the branch length. We
  calculate this random number using a method I took
  from~\cite[p. 137]{knu98:ar2}.
#+end_src
#+begin_src go <<Calculate the number of mutations, Ch.~\ref{ch:gt}>>=
  lambda := t * v.Length / 2.0
  x := math.Exp(-lambda)
  p := 1.0
  c := 0.0
  for p > x {
	  p *= r.Float64()
	  c++
  }
  v.Length = c
#+end_src
#+begin_src latex
  We import  \ty{math}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "math"
#+end_src
#+begin_src latex
  Before we print the tree, we label the leaves by calling
  \ty{labelLeaves} on the root with a node counter. If desired, we also
  label the internal nodes. Then we print the tree by calling the
  \ty{String} method on its root.
#+end_src
#+begin_src go <<Print tree, Ch.~\ref{ch:gt}>>=
  nc := 0
  nc = labelLeaves(root, nc)
  if *optL {
	  nc = 0
	  labelInternalNodes(root, nc)
  }
  fmt.Println(root)
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "fmt"
#+end_src
#+begin_src latex
  We label the leaves.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:gt}>>=
  func labelLeaves(v *nwk.Node, nc int) int {
	  if v == nil { return nc }
	  nc = labelLeaves(v.Child, nc)
	  if v.Child == nil {
		  nc++
		  v.Label = "T" + strconv.Itoa(nc)
	  }
	  nc = labelLeaves(v.Sib, nc)
	  return nc
  }
#+end_src
#+begin_src latex
  We import \ty{strconv}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:gt}>>=
  "strconv"
#+end_src
#+begin_src latex
  And we label the internal nodes.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:gt}>>=
  func labelInternalNodes(v *nwk.Node, nc int) int {
	  if v == nil { return nc }
	  if v.Child != nil {
		  nc++
		  v.Label = "N" + strconv.Itoa(nc)
	  }
	  nc = labelInternalNodes(v.Child, nc)
	  nc = labelInternalNodes(v.Sib, nc)
	  return nc
  }
#+end_src
#+begin_src latex
  We have finished \ty{genTree}, let's test it.
  \section*{Testing}
  The outline of our testing program contains hooks for imports and the
  testing logic.
#+end_src
#+begin_src go <<genTree_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:gt}>>
  )

  func TestGenTree(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:gt}>>
  }
#+end_src
#+begin_src latex
  We construct a set of tests and iterate over them.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:gt}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Ch.~\ref{ch:gt}>>
  for i, test := range tests {
	  //<<Run test, Ch.~\ref{ch:gt}>>
  }
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:gt}>>=
  "os/exec"
#+end_src
#+begin_src latex
  There are seven program-specific options. We seed the random number
  generator in every test, which leaves six options to test, plus a test
  without any options. So we have seven tests in total. We begin by
  testing all defaults, absolute branch lengths (\ty{-a}), coalescent
  (\ty{-c}), and iterations (\ty{-i}).
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:gt}>>=
  test := exec.Command("./genTree", "-s", "13")
  tests = append(tests, test)
  test = exec.Command("./genTree", "-s", "13", "-a")
  tests = append(tests, test)
  test = exec.Command("./genTree", "-s", "13", "-c")
  tests = append(tests, test)
  test = exec.Command("./genTree", "-s", "13", "-i", "2")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  The second set of tests contains labels for internal branches
  (\ty{-l}), sample size (\ty{-n}), and population mutation rate
  (\ty{-t}).
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:gt}>>=
  test = exec.Command("./genTree", "-s", "13", "-l")
  tests = append(tests, test)
  test = exec.Command("./genTree", "-s", "13", "-n", "9")
  tests = append(tests, test)
  test = exec.Command("./genTree", "-s", "13", "-t", "500")
#+end_src
#+begin_src latex
  For each test we compare what we get with what we want, which is
  stored in files labeled \ty{r1.txt}, \ty{r2.txt}, and so on.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:gt}>>=
  get, err := test.Output()
  if err != nil {
	  t.Errorf("couldn't run %q", test)
  }
  f := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := ioutil.ReadFile(f)
  if err != nil {
	  t.Errorf("couldn't open %q", f)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_src latex
  We import \ty{strconv}, \ty{ioutil}, and \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:gt}>>=
  "strconv"
  "io/ioutil"
  "bytes"
#+end_src
