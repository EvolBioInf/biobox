#+begin_src latex
  \section*{Introduction}
  The program \ty{plotLine} plots lines using
  \ty{gnuplot}~\cite{jan10:gnu}. It takes as input either two or three
  columns of data. The first two columns are the x- and y-coordinates,
  the optional third column is the group. Figure~\ref{fig:pl}A shows
  some example data for two groups, g1 and g2, and Figure~\ref{fig:pl}B
  its plot.

  \begin{figure}
    \begin{center}
      \begin{tabular}{cc}
	\textbf{A} & \textbf{B}\\
	\begin{tabular}{lll}
	  1 & 1 & g1\\
	  2 & 2 & g1\\
	  4 & 4 & g1\\
	  1 & 2 & g2\\
	  2 & 4 & g2\\
	  4 & 8 & g2
	\end{tabular}
	&
	\raisebox{-2.5cm}{\includegraphics{plotLine}}
      \end{tabular}
    \end{center}
    \caption{Example data (\textbf{A}) plotted with \ty{plotLine}
      (\textbf{B}).}\label{fig:pl}
  \end{figure}

  \section*{Implementation}
  The outline of \ty{plotLine} has hooks for imports, types, functions,
  and the logic of the main function.
#+end_src
#+begin_src go <<plotLine.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:pl}>>
  )
  //<<Types, Ch.~\ref{ch:pl}>>
  //<<Functions, Ch.~\ref{ch:pl}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:pl}>>
  }
#+end_src
#+begin_src latex
  In the main function we set the usage, declare the options, and parse
  the options. Then we set the type of the output window and parse the
  input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:pl}>>=
  //<<Set usage, Ch.~\ref{ch:pl}>>
  //<<Declare options, Ch.~\ref{ch:pl}>>
  //<<Parse options, Ch.~\ref{ch:pl}>>
  //<<Set type of output window, Ch.~\ref{ch:pl}>>
  //<<Parse input files, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  The usage consists of the actual usage message, an explanation of the
  purpose of \ty{plotLine}, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:pl}>>=
  u := "plotLine [-h] [option]... [file]..."
  p := "Plot lines from columns of x/y data " +
	  "and an optional group column."
  e := "plotLine foo.dat"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the version, we declare options concerning the axes, the
  plot type, and the graphics device.
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:pl}>>=
  var optV = flag.Bool("v", false, "version")
  //<<Declare axes options, Ch~\ref{ch:pl}>>
  //<<Declare plot type options, Ch.~\ref{ch:pl}>>
  //<<Declare device options, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "flag"
#+end_src
#+begin_src latex
  The options for axes define their labels, ranges, and scales.
#+end_src
#+begin_src go <<Declare axes options, Ch~\ref{ch:pl}>>=
  var optX = flag.String("x", "", "x-label")
  var optY = flag.String("y", "", "y-label")
  var optXX = flag.String("X", "s:e", "x-range")
  var optYY = flag.String("Y", "s:e", "y-range")
  var optL = flag.String("l", "", "log-scale (x|y|xy)")
#+end_src
#+begin_src latex
  By default, the plot consists of points and lines. But the user can
  opt for points only or lines only. She can also opt to write the
  \ty{gnuplot} script to file.
#+end_src
#+begin_src go <<Declare plot type options, Ch.~\ref{ch:pl}>>=
  var optPP = flag.Bool("P", false, "points only")
  var optLL = flag.Bool("L", false, "lines only")
  var optS = flag.String("s", "", "write gnuplot script to file")
#+end_src
#+begin_src latex
  The default output destination is the screen. Alternatively, the user
  can write the output to a file of encapsulated postscript. In that
  case, the user can also set the plot size.
#+end_src
#+begin_src go <<Declare device options, Ch.~\ref{ch:pl}>>=
  var optP = flag.String("p", "", "encapsulated postscript file")
  var optSS = flag.String("S", "x,y",
	  "size of postscript plot in inches, or, if stated, cm")
#+end_src
#+begin_src latex
  We parse the options and respond to \ty{-v} first, as this might
  terminate \ty{plotLine}. Then we collect the option values.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:pl}>>=
  flag.Parse()
  //<<Respond to \ty{-v}, Ch.~\ref{ch:pl}>>
  args := new(Args)
  //<<Collect option values, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  We respond to \ty{-v} by printing information about \ty{plotLine}.
#+end_src
#+begin_src go <<Respond to \ty{-v}, Ch.~\ref{ch:pl}>>=
  if *optV {
	  util.PrintInfo("plotLine")
  }
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_src latex
  We declare the type \ty{Args} and specify its fields as we go along.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:pl}>>=
  type Args struct {
	  //<<\ty{Args} fields, Ch.~\ref{ch:pl}>>
  }
#+end_src
#+begin_src latex
  We collect the option values for, \ty{-x}, \ty{-y}, \ty{-X}, \ty{-Y},
  \ty{-S}, \ty{-d}, \ty{-P}, \ty{-L}, \ty{-l}, \ty{-s}, and \ty{-p}.
#+end_src
#+begin_src go <<Collect option values, Ch.~\ref{ch:pl}>>=
  args.Xlab = *optX
  args.Ylab = *optY
  args.Xrange = *optXX
  args.Yrange = *optYY
  args.Size = *optSS
  args.Points = *optPP
  args.Lines = *optLL
  args.Log = *optL
  args.Script = *optS
  args.Ps = *optP
#+end_src
#+begin_src latex
  We add the corresponding fields to the structure \ty{Args}.
#+end_src
#+begin_src go <<\ty{Args} fields, Ch.~\ref{ch:pl}>>=
  Xlab, Ylab, Xrange, Yrange, Size string
  Points, Lines bool
  Log, Script, Ps string
#+end_src
#+begin_src latex
  The default output window is wxt. If we're running on the macOS
  command line, we switch to qt.
#+end_src
#+begin_src go <<Set type of output window, Ch.~\ref{ch:pl}>>=
  args.Win = "wxt"
  if runtime.GOOS == "darwin" {
	  args.Win = "qt"
  }
#+end_src
#+begin_src latex 
  We add the \ty{Win} field to \ty{Args}.
#+end_src
#+begin_src go <<\ty{Args} fields, Ch.~\ref{ch:pl}>>=
  Win string
#+end_src
#+begin_src latex
  We import \ty{runtime}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "runtime"
#+end_src
#+begin_src latex
  The remaining tokens on the command line are taken as input
  files. These are parsed with the function \ty{ParseFiles}, which
  applies the function \ty{scan} to each file. \ty{scan}, in turn, takes
  as argument the variable \ty{args} we just filled.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:pl}>>=
  files := flag.Args()
  clio.ParseFiles(files, scan, args)
#+end_src
#+begin_src latex
  Inside \ty{scan}, we retrieve the variable \ty{args} by type
  assertion, read the data, and extract the categories. Then we
  construct the script and the command to run the script, and at long
  last run it. Unless the user asked for the script, we delete it at the
  end.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:pl}>>=
  func scan(r io.Reader, a ...interface{}) {
	  args := a[0].(*Args)
	  //<<Read data, Ch.~\ref{ch:pl}>>
	  //<<Extract categories, Ch.~\ref{ch:pl}>>
	  //<<Construct script, Ch.~\ref{ch:pl}>>
	  //<<Construct command, Ch.~\ref{ch:pl}>>
	  //<<Run command, Ch.~\ref{ch:pl}>>
	  if args.Script == "" {
		  //<<Delete script, Ch.~\ref{ch:pl}>>
	  }
  }
#+end_src
#+begin_src latex
  We import \ty{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "io"
#+end_src
#+begin_src latex
  While reading the data, we skip comments. For each data point we are
  either given a category, or we ad an empty one. Having read the data,
  we check the number of columns.
#+end_src
#+begin_src go <<Read data, Ch.~\ref{ch:pl}>>=
  var data [][]string
  sc := bufio.NewScanner(r)
  for sc.Scan() {
	  if sc.Text()[0] == '#' { continue }
	  f := strings.Fields(sc.Text())
	  if len(f) == 2 { f = append(f, "") }
	  data = append(data, f)
  }
  //<<Check number of columns, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  We import \ty{bufio} and \ty{strings}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "bufio"
  "strings"
#+end_src
#+begin_src latex
  If the data has the wrong number of columns, there's bound to be a
  fundamental problem, so we bail with a friendly message.
#+end_src
#+begin_src go <<Check number of columns, Ch.~\ref{ch:pl}>>=
  ncol := 0
  if len(data) > 0 {
	  ncol = len(data[0])
  }
  if ncol < 2 || ncol > 3 {
	  m := "there should be 2 or 3 columns " +
		  "in the input, but you have %d\n"
	  log.Fatalf(m, ncol)
  }
#+end_src
#+begin_src latex
  We import \ty{log}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "log"
#+end_src
#+begin_src latex
  We extract the categories.
#+end_src
#+begin_src go <<Extract categories, Ch.~\ref{ch:pl}>>=
  var categories []string
  cm := make(map[string]bool)
  for _, d := range data {
	  if !cm[d[2]] {
		  categories = append(categories, d[2])
		  cm[d[2]] = true
	  }
  }
#+end_src
#+begin_src latex
  We open a file, write the script to it, and close it again.
#+end_src
#+begin_src go <<Construct script, Ch.~\ref{ch:pl}>>=
  var script *os.File
  //<<Open script file, Ch.~\ref{ch:pl}>>
  //<<Write script to file, Ch.~\ref{ch:pl}>>
  script.Close()
#+end_src
#+begin_src latex
  The script is written either to a unique file or to the file requested
  by the user.
#+end_src
#+begin_src go <<Open script file, Ch.~\ref{ch:pl}>>=
  var err error
  if args.Script == "" {
	  script, err = ioutil.TempFile("", "tmp_*.gp")
  } else {
	  script, err = os.Create(args.Script)
  }
  if err != nil {
	  log.Fatalf("can't create script file")
  }
#+end_src
#+begin_src latex
  We import \ty{ioutil}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "io/ioutil"
#+end_src
#+begin_src latex
  When writing the script, we begin with the terminal. Then we write the
  axes, the plot(s), and finally the data.
#+end_src
#+begin_src go <<Write script to file, Ch.~\ref{ch:pl}>>=
  //<<Write terminal, Ch.~\ref{ch:pl}>>
  //<<Write axes, Ch.~\ref{ch:pl}>>
  //<<Write plot, Ch.~\ref{ch:pl}>>
  //<<Write data, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  The terminal is either encapsulated postscript or a window. If it is a
  window, that window is persistent. If the user set the size, we pass
  that on.
#+end_src
#+begin_src go <<Write terminal, Ch.~\ref{ch:pl}>>=
  t := "set terminal"
  if args.Ps != "" {
	  t += " eps color"
  } else {
	  t += " " + args.Win + " persist"
  }
  if args.Size[0] != 'x' && args.Ps != "" {
	  t += " size " + args.Size
  }
  fmt.Fprintf(script, "%s\n", t)
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "fmt"
#+end_src
#+begin_src latex
   If the terminal is postscript, we also set the output file.
#+end_src
#+begin_src go <<Write terminal, Ch.~\ref{ch:pl}>>=
  if args.Ps != "" {
	  fmt.Fprintf(script, "set output \"%s\"\n", args.Ps)
  }
#+end_src
#+begin_src latex
  For the axes we write the labels and the log scale.
#+end_src
#+begin_src go <<Write axes, Ch.~\ref{ch:pl}>>=
  //<<Write axis labels, Ch.~\ref{ch:pl}>>
  //<<Write log scale, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  We label the x-axis and the y-axis.
#+end_src
#+begin_src go <<Write axis labels, Ch.~\ref{ch:pl}>>=
  if args.Xlab != "" {
	  fmt.Fprintf(script, "set xlabel \"%s\"\n", args.Xlab)
  }
  if args.Ylab != "" {
	  fmt.Fprintf(script, "set ylabel \"%s\"\n", args.Ylab)
  }
#+end_src
#+begin_src latex
  The user can log-scale the x-axis, the y-axis, or both.
#+end_src
#+begin_src go <<Write log scale, Ch.~\ref{ch:pl}>>=
  if strings.ContainsAny(args.Log, "xX") {
	  fmt.Fprintf(script, "set logscale x\n")
  }
  if strings.ContainsAny(args.Log, "yY") {
	  fmt.Fprintf(script, "set logscale y\n")
  }
#+end_src
#+begin_src latex
  The plot consists of a plot command, a style, and a separate plot
  for each category.
#+end_src
#+begin_src go <<Write plot, Ch.~\ref{ch:pl}>>=
  //<<Write plot command, Ch.~\ref{ch:pl}>>
  //<<Construct style, Ch.~\ref{ch:pl}>>
  //<<Write one plot per category, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  The plot command may include an x-range and/or a y-range.
#+end_src
#+begin_src go <<Write plot command, Ch.~\ref{ch:pl}>>=
  xr := ""
  yr := ""
  if args.Xrange[0] != 's' { xr = args.Xrange }
  if args.Yrange[0] != 's' { yr = args.Yrange }
  fmt.Fprintf(script, "plot[%s][%s]", xr, yr)
#+end_src
#+begin_src latex
  The default style is ``linespoints'', or \ty{lp}. However, the user
  might have opted either for ``points'', or for ``lines''.
#+end_src
#+begin_src go <<Construct style, Ch.~\ref{ch:pl}>>=
  style := "lp"
  if args.Points { style = "p" }
  if args.Lines { style = "l" }
#+end_src
#+begin_src latex
  We write the instruction for the first plot and then append an
  instruction for each remaining category.
#+end_src
#+begin_src go <<Write one plot per category, Ch.~\ref{ch:pl}>>=
  fmt.Fprintf(script, " \"-\" t \"%s\" w %s", categories[0], style)
  for i := 1; i < len(categories); i++ {
	  fmt.Fprintf(script, ", \"-\" t \"%s\" w %s",
		  categories[i], style)
  }
  fmt.Fprintf(script, "\n")
#+end_src
#+begin_src latex
  For each category, we write the corresponding data set and terminate
  it with \ty{e}.
#+end_src
#+begin_src go <<Write data, Ch.~\ref{ch:pl}>>=
  for i, c := range categories {
	  if i > 0 { fmt.Fprintf(script, "e\n") }
	  for _, d := range data {
		  if d[2] == c {
			  fmt.Fprintf(script, "%s\t%s\n",
				  d[0], d[1])
		  }
	  }
  }
#+end_src
#+begin_src latex
  We construct the \ty{gnuplot} command.
#+end_src
#+begin_src go <<Construct command, Ch.~\ref{ch:pl}>>=
  cmd := exec.Command("gnuplot", script.Name())
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "os/exec"
#+end_src
#+begin_src latex
  We run the command.
#+end_src
#+begin_src go <<Run command, Ch.~\ref{ch:pl}>>=
  err = cmd.Run()
  if err != nil {
	  log.Fatalf("can't run %q", cmd)
  }
#+end_src
#+begin_src latex
  We're done with the script and delete it.
#+end_src
#+begin_src go <<Delete script, Ch.~\ref{ch:pl}>>=
  err = os.Remove(script.Name())
  if err != nil {
	  log.Fatalf("can't remove %q", script.Name())
  }
#+end_src
#+begin_src latex
  We import \ty{os}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:pl}>>=
  "os"
#+end_src
#+begin_src latex
  We've finished \ty{plotLine}, let's test it.
  \section*{Testing}
  Out testing outline has hooks for imports and the testing logic.
#+end_src
#+begin_src go <<plotLine_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:pl}>>
  )

  func TestPlotLine(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:pl}>>
  }
#+end_src
#+begin_src latex
  We prepare a set of tests and then run them. In each test we write the
  output to a temporary \ty{gnuplot} script, so that we can compare what
  we get to what we want. After testing, we remove the \ty{gnuplot}
  script again.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:pl}>>=
  var tests []*exec.Cmd
  gf, err := ioutil.TempFile(".", "tmp_*.gp")
  if err != nil { log.Fatal("can't open script file") }
  g := gf.Name()
  //<<Prepare tests, Ch.~\ref{ch:pl}>>
  for i, test := range tests {
	  //<<Run test, Ch.~\ref{ch:pl}>>
  }
  err = os.Remove(g)
  if err != nil { log.Fatalf("can't delete %q", g) }
#+end_src
#+begin_src latex
  We import \ty{os} and \ty{ioutil}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:pl}>>=
  "os"
  "io/ioutil"
#+end_src
#+begin_src latex
  We create six sets of tests, lines \& points, axis labels, plot size,
  log-scaling, ranges, and combinations of log-scaling and ranges.
#+end_src
#+begin_src go <<Prepare tests, Ch.~\ref{ch:pl}>>=
  //<<Test lines and dots, Ch.~\ref{ch:pl}>>
  //<<Test axis labels, Ch.~\ref{ch:pl}>>
  //<<Test plot size, Ch.~\ref{ch:pl}>>
  //<<Test log-scaling, Ch.~\ref{ch:pl}>>
  //<<Test ranges, Ch.~\ref{ch:pl}>>
  //<<Test combinations of log-scaling and ranges, Ch.~\ref{ch:pl}>>
#+end_src
#+begin_src latex
  We have two sets of input data, \ty{test3.dat} with the three columns
  of data shown in Figure~\ref{fig:pl}A, and \ty{test2.dat}, with just
  the first two columns of group g1.

  We begin testing by drawing a plot of each, then we concentrate on
  \ty{test3.dat}. Every time our output is a \ty{gnuplot} file, which we
  can later compare with the output we want.
#+end_src
#+begin_src go <<Test lines and dots, Ch.~\ref{ch:pl}>>=
  test := exec.Command("./plotLine", "-s", g, "test2.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g, "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g, "-P", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g, "-L", "test3.dat")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:pl}>>=
  "os/exec"
#+end_src
#+begin_src latex
  We label the axes individually and then both of them.
#+end_src
#+begin_src go <<Test axis labels, Ch.~\ref{ch:pl}>>=
  test = exec.Command("./plotLine", "-s", g,
	  "-x", "x", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-y", "y", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-x", "x", "-y", "y", "test3.dat")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We set the plot size, which only works with postscript output.
#+end_src
#+begin_src go <<Test plot size, Ch.~\ref{ch:pl}>>=
  test = exec.Command("./plotLine", "-s", g,
	  "-p", "test.ps", "-S", "5,5", "test3.dat")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We set the x-axis to log-scale, the y-axis, and both of them.
#+end_src
#+begin_src go <<Test log-scaling, Ch.~\ref{ch:pl}>>=
  test = exec.Command("./plotLine", "-s", g,
	  "-l", "x", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-l", "y", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-l", "xy", "test3.dat")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We set a range for the x-axis, for the y-axis, and for both axes.
#+end_src
#+begin_src go <<Test ranges, Ch.~\ref{ch:pl}>>=
  test = exec.Command("./plotLine", "-s", g,
	  "-X", "0.1:10", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-Y", "0.2:100", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g, "-X", "0.1:10",
	  "-Y", "0.2:100", "test3.dat")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We combine log-scaling and limits.
#+end_src
#+begin_src go <<Test combinations of log-scaling and ranges, Ch.~\ref{ch:pl}>>=
  test = exec.Command("./plotLine", "-s", g,
	  "-X", "0.1:10", "-l", "x", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-Y", "0.2:100", "-l", "x", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-X", "0.1:10", "-l", "xy", "test3.dat")
  tests = append(tests, test)
  test = exec.Command("./plotLine", "-s", g,
	  "-X", "0.1:10", "-Y", "0.2:100", "-l", "xy", "test3.dat")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  For each test we compare what we get in \ty{g} with what we want
  in \ty{results/r1.gp}, \ty{results/r2.gp}, and so on. On a darwin
  system, the results files are called \ty{results/r1d.gp},
  \ty{results/r2d.gp}, and so on.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:pl}>>=
  err := test.Run()
  if err != nil { log.Fatalf("can't run %q", test) }
  get, err := ioutil.ReadFile(g)
  f := "results/r" + strconv.Itoa(i+1) 
  if runtime.GOOS == "darwin" { f += "d" }
  f += ".gp"
  want, err := ioutil.ReadFile(f)
  if err != nil { log.Fatalf("can't open %q", f) }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n",
		  string(get), string(want))
  }
#+end_src
#+begin_src latex
  We import \ty{log}, \ty{ioutil}, \ty{strconv}, \ty{runtime}, and
  \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:pl}>>=
  "log"
  "io/ioutil"
  "strconv"
  "runtime"
  "bytes"
#+end_src
