\nwfilename{}\nwbegindocs{0}\nwenddocs{}\nwbegindocs{1}\nwdocspar% ===> this file was generated automatically by noweave --- better not edit it
\section*{Introduction}
When you read a novel, you might like to look up the pages where a
particular character is mentioned. So you leaf through the book and
scan the pages for the character's name. If it's a long novel, this
takes longer than if its a short novel. But regardless of the novel's
length, this would be easier if it had an index. Most novels don't,
but most textbooks do. To look up a word in a textbook, just find it
in its index. In other words, by using an index, searching a text
becomes independent of its length.

A suffix tree is a perfect index in the sense that any word can be
looked up in it, not just particular terms considered important by an
author. Figure~\ref{fig:stConv} shows the suffix tree of the text
\[
t=\texttt{TTAAAATAT}
\]
The program \texttt{drawSt} takes as input a FASTA-formatted sequence
and draws its suffix tree.

\begin{figure}
  \begin{center}
    \begin{tabular}{cccccccccc}
        1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\
        \ty{T} & \ty{T} & \ty{A} & \ty{A} & \ty{A} & \ty{A} & \ty{T} &
        \ty{A} & \ty{T} & \ty{\$}
    \end{tabular}
  \end{center}
  \begin{center}
    \input{stree}
  \end{center}
  \caption{Suffix tree of t=\texttt{TTAAAATAT\$}.}\label{fig:stConv}
\end{figure}

Each leaf in the suffix tree in Figure~\ref{fig:stConv} is labeled by
a number. This refers to the starting position of the suffix obtained
by concatenating the characters on the path from the root to that
leaf. For example, leaf 7 has the path label \texttt{TAT\$}, the
suffix starting at position 7. This also means the tree has as many
leaves as there are suffixes---and by the same token characters---in
$t$. The last character, $\texttt{\$}$, is a sentinel that mismatches
every ordinary character to ensure that all suffixes end in a
mismatch, and hence a leaf.  Each internal node is also labeled by a
circled number, the length of its path label, also known as the node's
depth.

As explained in Chapter~\ref{ch:rep}, suffix trees are computed by
traversing their alphabetically ordered suffixes, their suffix
array. Table~\ref{tab:sa} shows the suffix array of $t$, $\sa$. If you
read it top to bottom, you get the same list of suffixes as reading
the leaves of the suffix tree left to right. Far left is the 10,
followed by 3, then 4, and so on.

The transformation of a suffix array to a suffix tree requires an
auxiliary array of the lengths of the matching prefixes of $\suf[i]$
and $\suf[i-1]$. This array is called the longest common prefix array,
$\lcp$, and is also shown in Table~\ref{tab:sa}. For example,
$\suf[4]=\texttt{AATAT\$}$ matches $\suf[3]=\texttt{AAATAT\$}$ in the
first two nucleotides, hence $\lcp[4]=2$.

\begin{table}
  \caption{Suffix array of $t=\texttt{TTAAAATAT\$}$.}\label{tab:sa}
  \begin{center}
  \begin{tabular}{cccl}
    \hline
    $i$ & $\sa[i]$ & $\lcp[i]$ & $\suf[i]$\\\hline
    \input{sa}
    \hline
  \end{tabular}
  \end{center}
\end{table}

A suffix tree is computed by finding the intervals in $\sa$
corresponding to its internal nodes. For example, the root corresponds
to interval $[1..10]$, the node colored in red to the interval
$[2..4]$. These intervals are augmented by their depths, $d$, to give
nodes of the form $d-[\ell..r]$. Figure~\ref{fig:stInt} shows this
interval version of the suffix tree in Figure~\ref{fig:stConv}. Its
shape is that of the suffix tree in Figre~\ref{fig:stConv} stripped of
its leaves. \texttt{DrawSt} can also draw suffix trees in the interval
style.

\begin{figure}
  \begin{center}
    \input{streeI.tex}
  \end{center}
  \caption{Suffix tree of $t=\texttt{TTAAAATAT\$}$ in interval
    notation.}\label{fig:stInt}
\end{figure}

We compute the interval tree using
Algorithm~\ref{alg:st}~\cite[p. 94]{ohl13:bio}. Nodes are written as
quartets $d, \ell, r, c$, where $d$ is the depth, $\ell$ and $r$ the
left and right interval borders, and $c$ the child. An as yet unknown
right border is $-1$, no child is $\bot$. This interval tree is then
converted to the full suffix tree.
\begin{algorithm}
  \caption{Algorithm for computing suffix
    tree~\cite[p. 94]{ohl13:bio}.}\label{alg:st}
  \begin{algorithmic}
    \input{algSt}
  \end{algorithmic}
\end{algorithm}

Apart from the trees in Figures~\ref{fig:stConv} and \ref{fig:stInt},
\texttt{drawSt} can also produce suffix trees in the
Newick\footnote{\texttt{evolution.genetics.washington.edu/phylip/newick\_doc.html}}
notation used for phylogenies. Figure~\ref{fig:stNwk}A shows the
Newick tree string of the. This string can be converted to a proper
tree (Figure~\ref{fig:stNwk}B. Now it isn't just the branch order that
carries meaning, but also the branch lengths, as they are proportional
to the length of the path label.
\begin{figure}
  \begin{center}
    \textbf{A}\\
    \tt
    (10:1,(((3:5,4:4,5:4):1,(8:1,6:3):1):1,(9:1,(2:7,7:2,1:9):1):1):1);
  \end{center}
  \begin{center}
    \textbf{B}\\
    \input{stNwk}
  \end{center}
\caption{Suffix tree drawn like a phylogeny. (\textbf{A}) Newick
  notation; (\textbf{B}) drawn as tree; the scale corresponds to one character.}\label{fig:stNwk}
\end{figure}

\section*{Implementation}
The program outline contains hooks for imports, variables, types,
methods, functions, and the logic of the main function.
\nwenddocs{}\nwbegincode{2}\sublabel{NW0-1Bt7tY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1Bt7tY-1}}}\moddef{drawSt.go~{\nwtagstyle{}\subpageref{NW0-1Bt7tY-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
package main
import (
          \LA{}Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}\RA{}
)
\LA{}Variables, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1ssEPz-1}}\RA{}
\LA{}Types, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2NSCiL-1}}\RA{}
\LA{}Methods, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1GShJr-1}}\RA{}
\LA{}Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}\RA{}
func main() \{
          \LA{}Main function, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2Ue6PL-1}}\RA{}
\}
\nwnotused{drawSt.go}\nwendcode{}\nwbegindocs{3}\nwdocspar
In the main function we set the usage, declare and parse the options,
and parse the input files.
\nwenddocs{}\nwbegincode{4}\sublabel{NW0-2Ue6PL-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2Ue6PL-1}}}\moddef{Main function, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2Ue6PL-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwenddeflinemarkup
\LA{}Set usage, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3QNT53-1}}\RA{}
\LA{}Declare options, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2H6NhM-1}}\RA{}
\LA{}Parse options, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3qXFXs-1}}\RA{}
\LA{}Parse input files, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4CQUp5-1}}\RA{}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{5}\nwdocspar
The usage consists of three parts, the actual usage message, an
explanation of the program's purpose, and an example command.
\nwenddocs{}\nwbegincode{6}\sublabel{NW0-3QNT53-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3QNT53-1}}}\moddef{Set usage, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3QNT53-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2Ue6PL-1}}\nwenddeflinemarkup
m := "drawSt [-h] [options] [files]"
p := "Draw suffix tree."
e := "drawSt foo.fasta"
clio.Usage(m, p, e)
\nwused{\\{NW0-2Ue6PL-1}}\nwendcode{}\nwbegindocs{7}\nwdocspar
We import \texttt{clio}.
\nwenddocs{}\nwbegincode{8}\sublabel{NW0-JyyYQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{\relax}{NW0-JyyYQ-2}\nwenddeflinemarkup
"github.com/evolbioinf/clio"
\nwalsodefined{\\{NW0-JyyYQ-2}\\{NW0-JyyYQ-3}\\{NW0-JyyYQ-4}\\{NW0-JyyYQ-5}\\{NW0-JyyYQ-6}\\{NW0-JyyYQ-7}\\{NW0-JyyYQ-8}}\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{9}\nwdocspar
By default, the program specifies the tree in \LaTeX{} using the
conventional notation of Figure~\ref{fig:stConv}. We declare options
for the two alternative formats, interval notation (\ty{-i},
Figure~\ref{fig:stInt}), and Newick notation (\ty{-n},
Figure~\ref{fig:stNwk}A). The user can also print the node depth
(\ty{-d}), label the nodes (\ty{-l}), change the default x- and
y-units (\ty{-x} \& \ty{-y}), add a sentinel character, and print the
program version (\ty{-v}).
\nwenddocs{}\nwbegincode{10}\sublabel{NW0-2H6NhM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2H6NhM-1}}}\moddef{Declare options, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2H6NhM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2Ue6PL-1}}\nwenddeflinemarkup
var optI = flag.Bool("i", false, "interval notation, LaTeX")
var optN = flag.Bool("n", false, "Newick notation, plain text")
var optD = flag.Bool("d", false, "show node depth")
var optL = flag.Bool("l", false, "label nodes")
var optX = flag.Float64("x", 1, "x-unit in LaTeX")
var optY = flag.Float64("y", 1.5, "y-unit in LaTeX")
var optS = flag.Bool("s", false, "add sentinel character")
var optV = flag.Bool("v", false, "print program version & " +
          "other information")
\nwused{\\{NW0-2Ue6PL-1}}\nwendcode{}\nwbegindocs{11}\nwdocspar
We import \texttt{flag}.
\nwenddocs{}\nwbegincode{12}\sublabel{NW0-JyyYQ-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-2}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-JyyYQ-1}{NW0-JyyYQ-3}\nwenddeflinemarkup
"flag"
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{13}\nwdocspar
We parse the options and respond to \ty{-v}.
\nwenddocs{}\nwbegincode{14}\sublabel{NW0-3qXFXs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3qXFXs-1}}}\moddef{Parse options, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3qXFXs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2Ue6PL-1}}\nwenddeflinemarkup
flag.Parse()
if *optV \{
          util.PrintInfo("drawSt")
\}
\nwused{\\{NW0-2Ue6PL-1}}\nwendcode{}\nwbegindocs{15}\nwdocspar
We import \texttt{util}.
\nwenddocs{}\nwbegincode{16}\sublabel{NW0-JyyYQ-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-3}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-JyyYQ-2}{NW0-JyyYQ-4}\nwenddeflinemarkup
"github.com/evolbioinf/biobox/util"
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{17}\nwdocspar
The remaining tokens on the command line are interpreted as input
files, which get parsed using the function \ty{scan}. It takes as
arguments the seven options specifying the tree format.
\nwenddocs{}\nwbegincode{18}\sublabel{NW0-4CQUp5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4CQUp5-1}}}\moddef{Parse input files, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4CQUp5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2Ue6PL-1}}\nwenddeflinemarkup
files := flag.Args()
clio.ParseFiles(files, scan, *optI, *optN, *optD, *optL, *optX,
          *optY, *optS)
\nwused{\\{NW0-2Ue6PL-1}}\nwendcode{}\nwbegindocs{19}\nwdocspar
In \texttt{scan}, we retrieve the options before iterating over the
sequences in the file.
\nwenddocs{}\nwbegincode{20}\sublabel{NW0-2wzOEh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{\relax}{NW0-2wzOEh-2}\nwenddeflinemarkup
func scan(r io.Reader, args ...interface\{\}) \{
          \LA{}Retrieve options, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3vLqZ0-1}}\RA{}
          \LA{}Iterate over sequences, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3YShji-1}}\RA{}
\}
\nwalsodefined{\\{NW0-2wzOEh-2}\\{NW0-2wzOEh-3}\\{NW0-2wzOEh-4}\\{NW0-2wzOEh-5}\\{NW0-2wzOEh-6}\\{NW0-2wzOEh-7}\\{NW0-2wzOEh-8}\\{NW0-2wzOEh-9}\\{NW0-2wzOEh-A}\\{NW0-2wzOEh-B}}\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{21}\nwdocspar
We import \ty{io}.
\nwenddocs{}\nwbegincode{22}\sublabel{NW0-JyyYQ-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-4}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-JyyYQ-3}{NW0-JyyYQ-5}\nwenddeflinemarkup
"io"
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{23}\nwdocspar
The seven options just passed are retrieved by reflection.
\nwenddocs{}\nwbegincode{24}\sublabel{NW0-3vLqZ0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3vLqZ0-1}}}\moddef{Retrieve options, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3vLqZ0-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-1}}\nwenddeflinemarkup
optI := args[0].(bool)
optN := args[1].(bool)
optD := args[2].(bool)
optL := args[3].(bool)
optX := args[4].(float64)
optY := args[5].(float64)
optS := args[6].(bool)
\nwused{\\{NW0-2wzOEh-1}}\nwendcode{}\nwbegindocs{25}\nwdocspar
For each sequence, we extract the sequence data, compute the suffix
tree, and draw it.
\nwenddocs{}\nwbegincode{26}\sublabel{NW0-3YShji-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3YShji-1}}}\moddef{Iterate over sequences, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3YShji-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-1}}\nwenddeflinemarkup
scanner := fasta.NewScanner(r)
for scanner.ScanSequence() \{
          sequence := scanner.Sequence()
          data := sequence.Data()
          \LA{}Compute suffix tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3rgVLJ-1}}\RA{}
          \LA{}Draw suffix tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2DUupi-1}}\RA{}
\}
\nwused{\\{NW0-2wzOEh-1}}\nwendcode{}\nwbegindocs{27}\nwdocspar
We import \ty{fasta}.
\nwenddocs{}\nwbegincode{28}\sublabel{NW0-JyyYQ-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-5}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-JyyYQ-4}{NW0-JyyYQ-6}\nwenddeflinemarkup
"github.com/evolbioinf/fasta"
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{29}\nwdocspar
A suffix tree consists of nodes, which in turn consist of a depth, a
left border, and a right border. The tree topology is established
through references to a child node and a sibling. In a conventional
suffix tree (Figure~\ref{fig:stConv}), each incoming edge of a node
has a label. We don't store the label but compute it whenever
required. To do that, we need to know not only the current node's
depth, but also its parent's, and hence include a pointer to parent. A
node also has an ID for easy reference and a level in the tree.
\nwenddocs{}\nwbegincode{30}\sublabel{NW0-2NSCiL-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2NSCiL-1}}}\moddef{Types, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2NSCiL-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{\relax}{NW0-2NSCiL-2}\nwenddeflinemarkup
type node struct \{
          d, l, r, id, level int
          child, sib, parent *node
\}
\nwalsodefined{\\{NW0-2NSCiL-2}\\{NW0-2NSCiL-3}}\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{31}\nwdocspar
For easy printing of nodes we implement \texttt{String}.
\nwenddocs{}\nwbegincode{32}\sublabel{NW0-1GShJr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1GShJr-1}}}\moddef{Methods, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1GShJr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{\relax}{NW0-1GShJr-2}\nwenddeflinemarkup
func (v *node) String() string \{
          if v == nil \{
                  return "!"
          \}
          s := fmt.Sprintf("%d-[%d..%d]", v.d, v.l, v.r)
          return s
\}
\nwalsodefined{\\{NW0-1GShJr-2}\\{NW0-1GShJr-3}}\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{33}\nwdocspar
A new node is constructed as a function of its depth, left and right
borders, and child node.
\nwenddocs{}\nwbegincode{34}\sublabel{NW0-2wzOEh-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-2}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-1}{NW0-2wzOEh-3}\nwenddeflinemarkup
func newNode(d, l, r int, child *node) *node \{
          n := new(node)
          n.d = d
          n.l = l
          n.r = r
          n.id = nodeId
          nodeId++
          if child != nil \{
                  n.child = child
                  child.parent = n
          \}
          return n
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{35}\nwdocspar
The node identifier is kept in a global variable.
\nwenddocs{}\nwbegincode{36}\sublabel{NW0-1ssEPz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1ssEPz-1}}}\moddef{Variables, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1ssEPz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwenddeflinemarkup
var nodeId int
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{37}\nwdocspar
According to Algorithm~\ref{alg:st}, the nodes are kept on a stack,
which we implement as a slice of node pointers~\cite[p. 92]{don16:go}.
\nwenddocs{}\nwbegincode{38}\sublabel{NW0-2NSCiL-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2NSCiL-2}}}\moddef{Types, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2NSCiL-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2NSCiL-1}{NW0-2NSCiL-3}\nwenddeflinemarkup
type stack []*node
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{39}\nwdocspar
We implement the three canonical stack functions, push, pop, and top.
\nwenddocs{}\nwbegincode{40}\sublabel{NW0-1GShJr-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1GShJr-2}}}\moddef{Methods, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1GShJr-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-1GShJr-1}{NW0-1GShJr-3}\nwenddeflinemarkup
func (s *stack) push(n *node) \{ *s = append(*s, n) \}
func (s *stack) pop() *node \{
          n := (*s)[len(*s)-1]
          *s = (*s)[0:len(*s)-1]
          return n
\}
func (s *stack) top() *node \{ return (*s)[len(*s)-1] \}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{41}\nwdocspar
To compute the suffix tree, we first prepare the data. The basis for
our suffix tree is the enhanced suffix array consisting of the suffix
array proper and the lcp array. The lcp array gets a -1 appended to
ensure all nodes are eventually popped from the stack in the while
loop of Algorithm~\ref{alg:st}.  We also initialize the focal node,
$v$, and the stack, onto which we push the root. Then we traverse the
lcp array.
\nwenddocs{}\nwbegincode{42}\sublabel{NW0-3rgVLJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3rgVLJ-1}}}\moddef{Compute suffix tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3rgVLJ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3YShji-1}}\nwenddeflinemarkup
\LA{}Prepare sequence data, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1dW9kd-1}}\RA{}
sa := esa.Sa(data)
lcp := esa.Lcp(data, sa)
lcp = append(lcp, -1)
n := len(lcp)
var v *node
root := newNode(0, 0, -1, nil)
stack := new(stack)
stack.push(root)
\LA{}Traverse lcp array, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3xidQP-1}}\RA{}
\nwused{\\{NW0-3YShji-1}}\nwendcode{}\nwbegindocs{43}\nwdocspar
If the user requested a sentinel character, we append that to the
sequence.
\nwenddocs{}\nwbegincode{44}\sublabel{NW0-1dW9kd-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1dW9kd-1}}}\moddef{Prepare sequence data, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1dW9kd-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3rgVLJ-1}}\nwenddeflinemarkup
if optS \{
          data = append(data, '$')
\}
\nwused{\\{NW0-3rgVLJ-1}}\nwendcode{}\nwbegindocs{45}\nwdocspar
We import \texttt{esa}.
\nwenddocs{}\nwbegincode{46}\sublabel{NW0-JyyYQ-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-6}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-JyyYQ-5}{NW0-JyyYQ-7}\nwenddeflinemarkup
"github.com/evolbioinf/esa"
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{47}\nwdocspar
Algorithm~\ref{alg:st} says that for each value in the lcp array,
nodes with depths greater $\lcp[i]$ are popped from the stack. If the
top node's depth is then less than $\lcp[i]$, a new node is pushed.
\nwenddocs{}\nwbegincode{48}\sublabel{NW0-3xidQP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3xidQP-1}}}\moddef{Traverse lcp array, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3xidQP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3rgVLJ-1}}\nwenddeflinemarkup
for i := 1; i < n; i++ \{
          l := i - 1
          for len(*stack) > 0 && lcp[i] < stack.top().d \{
                  \LA{}Pop node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3l6YnY-1}}\RA{}
          \}
          if len(*stack) > 0 && lcp[i] > stack.top().d \{
                  \LA{}Push node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-26fkIe-1}}\RA{}
          \}
\}
\nwused{\\{NW0-3rgVLJ-1}}\nwendcode{}\nwbegindocs{49}\nwdocspar
When popping nodes from the stack, we check whether they are children
of the top node. Since adding a child is an operation we need
repeatedly, we delegate it to a method.
\nwenddocs{}\nwbegincode{50}\sublabel{NW0-3l6YnY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3l6YnY-1}}}\moddef{Pop node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3l6YnY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3xidQP-1}}\nwenddeflinemarkup
stack.top().r = i - 1
v = stack.pop()
l = v.l
if len(*stack) > 0 && lcp[i] <= stack.top().d \{
          p := stack.top()
          p.addChild(v)
          v = nil
\}
\nwused{\\{NW0-3xidQP-1}}\nwendcode{}\nwbegindocs{51}\nwdocspar
When adding a child to a node, we first assign the child's parent
link. Then we either assign the child to the parent's child link, or
insert it in the correct position among its siblings. This position is
either on the left of its siblings, in between them, or to their
right.
\nwenddocs{}\nwbegincode{52}\sublabel{NW0-1GShJr-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1GShJr-3}}}\moddef{Methods, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1GShJr-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-1GShJr-2}{\relax}\nwenddeflinemarkup
func (p *node) addChild(c *node) \{
          c.parent = p
          if p.child == nil \{
                  p.child = c
          \} else \{
                  \LA{}Insert child on the left of siblings?, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4M2Ra-1}}\RA{}
                  \LA{}Insert child between siblings?, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1Sro03-1}}\RA{}
                  \LA{}Insert child on the right of siblings?, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3krEmu-1}}\RA{}
          \}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{53}\nwdocspar
If the child's left border is to the left of its first sibling, the
new child becomes the first sibling. This child has now been taken
care of, so the function returns.
\nwenddocs{}\nwbegincode{54}\sublabel{NW0-4M2Ra-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4M2Ra-1}}}\moddef{Insert child on the left of siblings?, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4M2Ra-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1GShJr-3}}\nwenddeflinemarkup
w := p.child
if c.l < w.l \{
          p.child = c
          c.sib = w
          return
\}
\nwused{\\{NW0-1GShJr-3}}\nwendcode{}\nwbegindocs{55}\nwdocspar
If the new child's left border is between that of two siblings, it is
inserted between them.
\nwenddocs{}\nwbegincode{56}\sublabel{NW0-1Sro03-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1Sro03-1}}}\moddef{Insert child between siblings?, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1Sro03-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1GShJr-3}}\nwenddeflinemarkup
for w.sib != nil \{
          if c.l > w.r && c.l < w.sib.l \{
                  c.sib = w.sib
                  w.sib = c
                  return
          \}
          w = w.sib
\}
\nwused{\\{NW0-1GShJr-3}}\nwendcode{}\nwbegindocs{57}\nwdocspar
If the child is still not assigned, it becomes the last sibling.
\nwenddocs{}\nwbegincode{58}\sublabel{NW0-3krEmu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3krEmu-1}}}\moddef{Insert child on the right of siblings?, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3krEmu-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1GShJr-3}}\nwenddeflinemarkup
w.sib = c
\nwused{\\{NW0-1GShJr-3}}\nwendcode{}\nwbegindocs{59}\nwdocspar
After removing nodes from the stack, we might also push a new node.
\nwenddocs{}\nwbegincode{60}\sublabel{NW0-26fkIe-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-26fkIe-1}}}\moddef{Push node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-26fkIe-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3xidQP-1}}\nwenddeflinemarkup
w := newNode(lcp[i], l, -1, v)
stack.push(w)
v = nil
\nwused{\\{NW0-3xidQP-1}}\nwendcode{}\nwbegindocs{61}\nwdocspar
There are three tree formats, conventional (Figure~\ref{fig:stConv}),
interval (Figure~\ref{fig:stInt}), and Newick
(Figure~\ref{fig:stNwk}). If we are not drawing an interval tree, we
need to add leaves and node levels to our tree.
\nwenddocs{}\nwbegincode{62}\sublabel{NW0-2DUupi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2DUupi-1}}}\moddef{Draw suffix tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2DUupi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3YShji-1}}\nwenddeflinemarkup
if !optI \{
          \LA{}Add leaves, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1860vx-1}}\RA{}
          \LA{}Add levels, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2LGuIG-1}}\RA{}
\}
if optI \{
          \LA{}Print interval tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2dbD1x-1}}\RA{}
\} else if optN \{
          \LA{}Print Newick tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2HrrqA-1}}\RA{}
\} else \{
          \LA{}Print conventional tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-29MzDO-1}}\RA{}
\}
\nwused{\\{NW0-3YShji-1}}\nwendcode{}\nwbegindocs{63}\nwdocspar
We add the node levels, for which we need a preorder traversal. Since
we won't reuse this, we write it as a simple recursion.
\nwenddocs{}\nwbegincode{64}\sublabel{NW0-2LGuIG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2LGuIG-1}}}\moddef{Add levels, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2LGuIG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2DUupi-1}}\nwenddeflinemarkup
preorder(root)
\nwused{\\{NW0-2DUupi-1}}\nwendcode{}\nwbegindocs{65}\nwdocspar
A node's level is that of its parent plus one.
\nwenddocs{}\nwbegincode{66}\sublabel{NW0-2wzOEh-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-3}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-2}{NW0-2wzOEh-4}\nwenddeflinemarkup
func preorder(v *node) \{
          if v != nil \{
                  if v.parent != nil \{
                          v.level = v.parent.level + 1
                  \}
                  preorder(v.child)
                  preorder(v.sib)
          \}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{67}\nwdocspar
Adding leaves requires another tree traversal. This time, we delegate
it to a reusable function, \texttt{traverse}. \ty{traverse} takes as
argument the root of a tree and a function it applies to each node, in
this case \texttt{addLeaves}. \texttt{AddLeaves} in turn takes as
argument the suffix array.
\nwenddocs{}\nwbegincode{68}\sublabel{NW0-1860vx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1860vx-1}}}\moddef{Add leaves, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1860vx-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2DUupi-1}}\nwenddeflinemarkup
traverse(root, addLeaves, sa)
\nwused{\\{NW0-2DUupi-1}}\nwendcode{}\nwbegindocs{69}\nwdocspar
To make \texttt{traverse} useful in diverse traversals, it takes a
variadic variable consisting of empty interfaces. These and the
current node are the arguments of the function applied to every
node. We add leaves in a post order traversal, so we implement this
variant.
\nwenddocs{}\nwbegincode{70}\sublabel{NW0-2wzOEh-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-4}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-3}{NW0-2wzOEh-5}\nwenddeflinemarkup
func traverse(v *node, fn nodeAction, args ...interface\{\}) \{
          if v != nil \{
                  traverse(v.child, fn, args...)
                  traverse(v.sib, fn, args...)
                  fn(v, args...)
          \}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{71}\nwdocspar
We define the type of this function, \texttt{nodeAction}.
\nwenddocs{}\nwbegincode{72}\sublabel{NW0-2NSCiL-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2NSCiL-3}}}\moddef{Types, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2NSCiL-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2NSCiL-2}{\relax}\nwenddeflinemarkup
type nodeAction func(*node, ...interface\{\})
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{73}\nwdocspar
If we are dealing with a leaf of the interval tree, all elements of
its interval become leaves.  Otherwise, we have to compare its interval
to that of its children.
\nwenddocs{}\nwbegincode{74}\sublabel{NW0-2wzOEh-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-5}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-4}{NW0-2wzOEh-6}\nwenddeflinemarkup
func addLeaves(p *node, args ...interface\{\}) \{
          sa := args[0].([]int)
          l := len(sa)
          if p.child == nil \{
                  for i := p.l; i <= p.r; i++ \{
                          c := newNode(l - sa[i], i, i, nil)
                          p.addChild(c)
                  \}
          \} else \{
                  \LA{}Compare parent interval to child intervals, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1FIDSz-1}}\RA{}
          \}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{75}\nwdocspar
Any part of an internal node's interval not found in its children is
filled with leaves. We discover these gaps by considering the left,
middle and right parts of the parent's interval.
\nwenddocs{}\nwbegincode{76}\sublabel{NW0-1FIDSz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1FIDSz-1}}}\moddef{Compare parent interval to child intervals, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1FIDSz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-5}}\nwenddeflinemarkup
\LA{}Add leaves on the left, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4VG5qB-1}}\RA{}
\LA{}Add leaves in the middle, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-ybLGo-1}}\RA{}
\LA{}Add leaves on the right, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4R4gkk-1}}\RA{}
\nwused{\\{NW0-2wzOEh-5}}\nwendcode{}\nwbegindocs{77}\nwdocspar
We fill the gap between the parent's left border and the first
child's.
\nwenddocs{}\nwbegincode{78}\sublabel{NW0-4VG5qB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4VG5qB-1}}}\moddef{Add leaves on the left, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4VG5qB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1FIDSz-1}}\nwenddeflinemarkup
for i := p.l; i < p.child.l; i++ \{
          c := newNode(l - sa[i], i, i, nil)
          p.addChild(c)
\}
\nwused{\\{NW0-1FIDSz-1}}\nwendcode{}\nwbegindocs{79}\nwdocspar
We fill the gaps between siblings.
\nwenddocs{}\nwbegincode{80}\sublabel{NW0-ybLGo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-ybLGo-1}}}\moddef{Add leaves in the middle, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-ybLGo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1FIDSz-1}}\nwenddeflinemarkup
v := p.child
for v.sib != nil \{
          x := v.sib.l
          for i := v.r+1; i < x; i++ \{
                  c := newNode(l - sa[i], i, i, nil)
                  p.addChild(c)
          \}
          v = v.sib
\}
\nwused{\\{NW0-1FIDSz-1}}\nwendcode{}\nwbegindocs{81}\nwdocspar
We fill the gap between the right border of the last sibling and the
parent's right border.
\nwenddocs{}\nwbegincode{82}\sublabel{NW0-4R4gkk-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4R4gkk-1}}}\moddef{Add leaves on the right, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4R4gkk-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1FIDSz-1}}\nwenddeflinemarkup
for i := v.r+1; i <= p.r; i++ \{
          c := newNode(l - sa[i], i, i, nil)
          p.addChild(c)
\}
\nwused{\\{NW0-1FIDSz-1}}\nwendcode{}\nwbegindocs{83}\nwdocspar
The tree is now ready to be drawn. For a string of length $n$, it has
$n$ leaves in the x-dimension and $n$ characters in the
y-dimension. So we could try to fit our suffix tree into an $n\times
n$ square. And while the $x$-dimension really is a function of $n$, it
turns out that the $y$-dimension is better taken from the maximum node
level.

For the conventional tree (Figure~\ref{fig:stConv}), we print the
picture header, the edges, the nodes, and the picture footer. The
picture header takes as arguments the picture dimensions. The
x-dimension is equal to the lengrh of the input string times the
x-scale factor. The y-dimension is equal to the negative of the
largest node level times the y-scale factor.
\nwenddocs{}\nwbegincode{84}\sublabel{NW0-29MzDO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-29MzDO-1}}}\moddef{Print conventional tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-29MzDO-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2DUupi-1}}\nwenddeflinemarkup
l := len(data)
x := float64(l) * optX
m := maxNodeLevel(root, 0)
y := float64(m) * optY
fmt.Printf("\\\\begin\{pspicture\}(%.2g,%.2g)(%.2g,%.2g)\\n",
          0.0, -y, x, 0.0)
fmt.Printf("\\\\psset\{xunit=%.3g, yunit=%.3g\}\\n", optX, optY)
traverse(root, drawCedge, sa, data)
traverse(root, drawCnode, sa, optL, optD)
fmt.Printf("\\\\end\{pspicture\}\\n")
\nwused{\\{NW0-2DUupi-1}}\nwendcode{}\nwbegindocs{85}\nwdocspar
We find the maximum node level by recursion.
\nwenddocs{}\nwbegincode{86}\sublabel{NW0-2wzOEh-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-6}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-5}{NW0-2wzOEh-7}\nwenddeflinemarkup
func maxNodeLevel(v *node, m int) int \{
          if v != nil \{
                  if v.level > m \{
                          m = v.level
                  \}
                  m = maxNodeLevel(v.child, m)
                  m = maxNodeLevel(v.sib, m)
          \}
          return m
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{87}\nwdocspar
We import \texttt{fmt}.
\nwenddocs{}\nwbegincode{88}\sublabel{NW0-JyyYQ-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-7}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-JyyYQ-6}{NW0-JyyYQ-8}\nwenddeflinemarkup
"fmt"
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{89}\nwdocspar
Nodes are drawn in three steps, the arguments are retrieved, the node
is drawn and labeled.
\nwenddocs{}\nwbegincode{90}\sublabel{NW0-2wzOEh-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-7}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-6}{NW0-2wzOEh-8}\nwenddeflinemarkup
func drawCnode(v *node, args ...interface\{\}) \{
          \LA{}Retrieve conventional node arguments, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1SBw8M-1}}\RA{}
          \LA{}Write conventional node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1umSmz-1}}\RA{}
          \LA{}Label conventional node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1ZT7jY-1}}\RA{}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{91}\nwdocspar
We retrieve the arguments just passed by reflection.
\nwenddocs{}\nwbegincode{92}\sublabel{NW0-1SBw8M-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1SBw8M-1}}}\moddef{Retrieve conventional node arguments, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1SBw8M-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-7}}\nwenddeflinemarkup
sa := args[0].([]int)
nodeLabel := args[1].(bool)
depth := args[2].(bool)
\nwused{\\{NW0-2wzOEh-7}}\nwendcode{}\nwbegindocs{93}\nwdocspar
The x-coordinate of a node is the middle of its interval, the
y-coordinate the node level. Nodes are either dots or boxes around a
node identifier.
\nwenddocs{}\nwbegincode{94}\sublabel{NW0-1umSmz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1umSmz-1}}}\moddef{Write conventional node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1umSmz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-7}}\nwenddeflinemarkup
x := float64(v.l + v.r) / 2.0
if nodeLabel \{
          fmt.Printf("\\\\rput(%.3g,%d)\{\\\\rnode\{%d\}\{" +
                  "\\\\psframebox[linecolor=lightgray]\{%d\}\}\}",
                  x, -v.level, v.id, v.id)
\} else \{
          fmt.Printf("\\\\dotnode(%.3g,%d)\{%d\}\\n",
                  x, -v.level, v.id)
\}
\nwused{\\{NW0-2wzOEh-7}}\nwendcode{}\nwbegindocs{95}\nwdocspar
Leaves are labeled by the suffix position. Internal nodes might be
labeled by their string depth, which we place in a box to distinguish
it from the labels of nodes and leaves.
\nwenddocs{}\nwbegincode{96}\sublabel{NW0-1ZT7jY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1ZT7jY-1}}}\moddef{Label conventional node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1ZT7jY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-7}}\nwenddeflinemarkup
if v.child == nil \{
          fmt.Printf("\\\\nput\{-90\}\{%d\}\{%d\}\\n",
                  v.id, sa[v.l]+1)
\} else if depth \{
          fmt.Printf("\\\\nput\{0\}\{%d\}\{" +
                  "\\\\ovalnode[linecolor=lightgray]\{%d\}\{%d\}\}\\n",
                  v.id, v.id, v.d)
\}
\nwused{\\{NW0-2wzOEh-7}}\nwendcode{}\nwbegindocs{97}\nwdocspar
For each node that isn't the root, we draw an edge to its parent. This
is labeled with a substring of the input string. The starting point of
the label is the starting point of the suffix minus the parent's
depth. The length of the label is the current depth minus the parent's
depth.
\nwenddocs{}\nwbegincode{98}\sublabel{NW0-2wzOEh-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-8}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-7}{NW0-2wzOEh-9}\nwenddeflinemarkup
func drawCedge(v *node, args ...interface\{\}) \{
          if v.parent == nil \{ return \}
          sa := args[0].([]int)
          seq := args[1].([]byte)
          start := sa[v.l] + v.parent.d
          l := v.d - v.parent.d
          label := string(seq[start:start+l])
          \LA{}Print edge label, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4gPWgW-1}}\RA{}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{99}\nwdocspar
To print the edge label, we prepare it and then place it.
\nwenddocs{}\nwbegincode{100}\sublabel{NW0-4gPWgW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4gPWgW-1}}}\moddef{Print edge label, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4gPWgW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-8}}\nwenddeflinemarkup
\LA{}Prepare edge label, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4ES1xV-1}}\RA{}
\LA{}Place edge label, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3nKLIM-1}}\RA{}
\nwused{\\{NW0-2wzOEh-8}}\nwendcode{}\nwbegindocs{101}\nwdocspar
We abridge long edge labels using interval notation. The resulting
label may contain a dollar character, the classical terminator
symbol. As the dollar is part of the \LaTeX{} syntax, we escape it.
\nwenddocs{}\nwbegincode{102}\sublabel{NW0-4ES1xV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4ES1xV-1}}}\moddef{Prepare edge label, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4ES1xV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-4gPWgW-1}}\nwenddeflinemarkup
ll := len(label)
if ll > 5 \{
          label = label[:1] + "..." + label[ll-1:ll]
\}
label = strings.Replace(label, "$", "\\\\$", 1)
\nwused{\\{NW0-4gPWgW-1}}\nwendcode{}\nwbegindocs{103}\nwdocspar
We place the label in the center of a text path along a line from the
parent to the child.
\nwenddocs{}\nwbegincode{104}\sublabel{NW0-3nKLIM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3nKLIM-1}}}\moddef{Place edge label, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3nKLIM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-4gPWgW-1}}\nwenddeflinemarkup
x1 := float64(v.parent.l + v.parent.r) / 2.0
y1 := -v.parent.level
x2 := float64(v.l + v.r) / 2.0
y2 := -v.level
tp := "\\\\pstextpath[c]\{\\\\psline[linecolor=lightgray](%.3g,%d)" +
          "(%.3g,%d)\}\{\\\\texttt\{%s\}\}\\n"
fmt.Printf(tp, x1, y1, x2, y2, label)
\nwused{\\{NW0-4gPWgW-1}}\nwendcode{}\nwbegindocs{105}\nwdocspar
We import \ty{strings}.
\nwenddocs{}\nwbegincode{106}\sublabel{NW0-JyyYQ-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-JyyYQ-8}}}\moddef{Imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-JyyYQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-JyyYQ-7}{\relax}\nwenddeflinemarkup
"strings"
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{107}\nwdocspar
We are done with the conventional tree (Figure~\ref{fig:stConv}) and
move to the interval tree (Figure~\ref{fig:stInt}).  We print this as
a ps-tree with node separation of 2 points and level separation of 1
cm.
\nwenddocs{}\nwbegincode{108}\sublabel{NW0-2dbD1x-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2dbD1x-1}}}\moddef{Print interval tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2dbD1x-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2DUupi-1}}\nwenddeflinemarkup
fmt.Printf("\\\\psset\{nodesep=2pt, levelsep=1cm\}\\n")
printIntervals(root)
\nwused{\\{NW0-2DUupi-1}}\nwendcode{}\nwbegindocs{109}\nwdocspar
The function \ty{printIntervals} is recursive. Inside it, we
distinguish between leaves and internal nodes of the interval tree.
\nwenddocs{}\nwbegincode{110}\sublabel{NW0-2wzOEh-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-9}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-8}{NW0-2wzOEh-A}\nwenddeflinemarkup
func printIntervals(i *node) \{
          if i == nil \{ return \}
          \LA{}Is $i$ a leaf? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-MgUMW-1}}\RA{}
          \LA{}Is $i$ an internal node? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1ETjx5-1}}\RA{}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{111}\nwdocspar
If $i$ is a leaf, we print its ps-tree representation.
\nwenddocs{}\nwbegincode{112}\sublabel{NW0-MgUMW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MgUMW-1}}}\moddef{Is $i$ a leaf? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-MgUMW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-9}}\nwenddeflinemarkup
if i.child == nil \{
          s := "\\\\Tr\{$%d-[%d...%d]$\}\\n"
          fmt.Printf(s, i.d, i.l+1, i.r+1)
\}
\nwused{\\{NW0-2wzOEh-9}}\nwendcode{}\nwbegindocs{113}\nwdocspar
If $i$ is an internal node, we open it and add children and siblings
to the subtree rooted on it.
\nwenddocs{}\nwbegincode{114}\sublabel{NW0-1ETjx5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1ETjx5-1}}}\moddef{Is $i$ an internal node? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1ETjx5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-9}}\nwenddeflinemarkup
\LA{}Open internal node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1BUO31-1}}\RA{}
\LA{}Add child to internal node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1Jymm8-1}}\RA{}
\LA{}Add sibling to internal node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2UZ4T9-1}}\RA{}
\nwused{\\{NW0-2wzOEh-9}}\nwendcode{}\nwbegindocs{115}\nwdocspar
If the current node has children, it is an internal node and the root
of a subtree.
\nwenddocs{}\nwbegincode{116}\sublabel{NW0-1BUO31-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1BUO31-1}}}\moddef{Open internal node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1BUO31-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1ETjx5-1}}\nwenddeflinemarkup
if i.child != nil \{
          s := "\\\\pstree\{\\\\Tr\{$%d-[%d...%d]$\}\}\{\\n"
          fmt.Printf(s, i.d, i.l+1, i.r+1)
\}
\nwused{\\{NW0-1ETjx5-1}}\nwendcode{}\nwbegindocs{117}\nwdocspar
We follow the child link and note whether or not the subtree is
closed.
\nwenddocs{}\nwbegincode{118}\sublabel{NW0-1Jymm8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1Jymm8-1}}}\moddef{Add child to internal node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-1Jymm8-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1ETjx5-1}}\nwenddeflinemarkup
printIntervals(i.child)
closed := false
if i.child != nil \{
          fmt.Printf("\}\\n")
          closed = true
\}
\nwused{\\{NW0-1ETjx5-1}}\nwendcode{}\nwbegindocs{119}\nwdocspar
We follow the child link and if we end up with an as yet open internal
node, we close that.
\nwenddocs{}\nwbegincode{120}\sublabel{NW0-2UZ4T9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2UZ4T9-1}}}\moddef{Add sibling to internal node, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2UZ4T9-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1ETjx5-1}}\nwenddeflinemarkup
printIntervals(i.sib)
if i.child != nil && !closed \{
          fmt.Printf("\}\\n")
\}
\nwused{\\{NW0-1ETjx5-1}}\nwendcode{}\nwbegindocs{121}\nwdocspar
The interval tree is finished and we get to the third and last tree
version, Newick (Figure~\ref{fig:stNwk}A). To write the tree in that
format, we follow the explanation given in the keyword tree package,
\ty{kt}\footnote{\texttt{github.com/evolbioinf/kt}}. We call a new
traversal function with the suffix array as argument, for labeling the
leaves.
\nwenddocs{}\nwbegincode{122}\sublabel{NW0-2HrrqA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2HrrqA-1}}}\moddef{Print Newick tree, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2HrrqA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2DUupi-1}}\nwenddeflinemarkup
printNewick(root, sa)
\nwused{\\{NW0-2DUupi-1}}\nwendcode{}\nwbegindocs{123}\nwdocspar
In the implementation, we test whether a node is \emph{not} the first
child, whether it's a leaf, whether it's an internal node, and whether
it's the root.
\nwenddocs{}\nwbegincode{124}\sublabel{NW0-2wzOEh-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-A}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-9}{NW0-2wzOEh-B}\nwenddeflinemarkup
func printNewick(v *node, args ...interface\{\}) \{
          if v == nil \{ return \}
          sa := args[0].([]int)
          \LA{}Is $v$ not a first child? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-utcUk-1}}\RA{}
          \LA{}Is $v$ a leaf? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2BeTlA-1}}\RA{}
          \LA{}Is $v$ an internal node? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-jJjnW-1}}\RA{}
          \LA{}Is $v$ the root? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3HF8xA-1}}\RA{}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{125}\nwdocspar
Nodes subsequent to the first child are preceded by commas.
\nwenddocs{}\nwbegincode{126}\sublabel{NW0-utcUk-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-utcUk-1}}}\moddef{Is $v$ not a first child? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-utcUk-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-A}}\nwenddeflinemarkup
if v.parent != nil && v.parent.child.id != v.id \{
          fmt.Printf(",")
\}
\nwused{\\{NW0-2wzOEh-A}}\nwendcode{}\nwbegindocs{127}\nwdocspar
Leaves are labeled.
\nwenddocs{}\nwbegincode{128}\sublabel{NW0-2BeTlA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2BeTlA-1}}}\moddef{Is $v$ a leaf? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2BeTlA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-A}}\nwenddeflinemarkup
if v.child == nil \{
        label(v, sa)
\}
\nwused{\\{NW0-2wzOEh-A}}\nwendcode{}\nwbegindocs{129}\nwdocspar
A node label consists of the starting position of the corresponding
suffix and a branch length.
\nwenddocs{}\nwbegincode{130}\sublabel{NW0-2wzOEh-B}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2wzOEh-B}}}\moddef{Functions, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2wzOEh-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-1Bt7tY-1}}\nwprevnextdefs{NW0-2wzOEh-A}{\relax}\nwenddeflinemarkup
func label(v *node, sa []int) \{
          fmt.Printf("%d", sa[v.l] + 1)
          \LA{}Branch length, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2zl6y7-1}}\RA{}
\}
\nwused{\\{NW0-1Bt7tY-1}}\nwendcode{}\nwbegindocs{131}\nwdocspar
The branch length consists of the number of characters on the incoming
edge.
\nwenddocs{}\nwbegincode{132}\sublabel{NW0-2zl6y7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2zl6y7-1}}}\moddef{Branch length, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2zl6y7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-B}\\{NW0-jJjnW-1}}\nwenddeflinemarkup
if v.parent != nil \{
          l := v.d - v.parent.d
          fmt.Printf(":%d", l)
\}
\nwused{\\{NW0-2wzOEh-B}\\{NW0-jJjnW-1}}\nwendcode{}\nwbegindocs{133}\nwdocspar
Internal nodes are enclosed in brackets and come with the length of
the edge to the parent.
\nwenddocs{}\nwbegincode{134}\sublabel{NW0-jJjnW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-jJjnW-1}}}\moddef{Is $v$ an internal node? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-jJjnW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-A}}\nwenddeflinemarkup
if v.child != nil \{ fmt.Printf("(") \}
printNewick(v.child, sa)
printNewick(v.sib, sa)
if v.child != nil \{
          fmt.Printf(")")
          \LA{}Branch length, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-2zl6y7-1}}\RA{}
\}
\nwused{\\{NW0-2wzOEh-A}}\nwendcode{}\nwbegindocs{135}\nwdocspar
The root is denoted by a semicolon and a newline.
\nwenddocs{}\nwbegincode{136}\sublabel{NW0-3HF8xA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3HF8xA-1}}}\moddef{Is $v$ the root? Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3HF8xA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2wzOEh-A}}\nwenddeflinemarkup
if v.parent == nil \{
          fmt.Printf(";\\n")
\}
\nwused{\\{NW0-2wzOEh-A}}\nwendcode{}\nwbegindocs{137}\nwdocspar
The program \ty{drawSt} is finished, so we test it next.

\section*{Testing}
Our testing outline has hooks for imports and the testing logic.
\nwenddocs{}\nwbegincode{138}\sublabel{NW0-2WJytI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2WJytI-1}}}\moddef{drawSt\_test.go~{\nwtagstyle{}\subpageref{NW0-2WJytI-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
package main

import (
          "testing"
          \LA{}Testing imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4LVHpY-1}}\RA{}
)

func TestDrawSt(t *testing.T) \{
          \LA{}Testing logic, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3pRrcD-1}}\RA{}
\}
\nwnotused{drawSt\_test.go}\nwendcode{}\nwbegindocs{139}\nwdocspar
We test in two steps. First we construct the tests, then we iterate
over them and run them.
\nwenddocs{}\nwbegincode{140}\sublabel{NW0-3pRrcD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3pRrcD-1}}}\moddef{Testing logic, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-3pRrcD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2WJytI-1}}\nwenddeflinemarkup
var tests []*exec.Cmd
\LA{}Construct tests, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4T8Qxp-1}}\RA{}
for i, test := range tests \{
          \LA{}Run test, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-41eGC9-1}}\RA{}
\}
\nwused{\\{NW0-2WJytI-1}}\nwendcode{}\nwbegindocs{141}\nwdocspar
We import \ty{exec}.
\nwenddocs{}\nwbegincode{142}\sublabel{NW0-4LVHpY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4LVHpY-1}}}\moddef{Testing imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4LVHpY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2WJytI-1}}\nwprevnextdefs{\relax}{NW0-4LVHpY-2}\nwenddeflinemarkup
"os/exec"
\nwalsodefined{\\{NW0-4LVHpY-2}}\nwused{\\{NW0-2WJytI-1}}\nwendcode{}\nwbegindocs{143}\nwdocspar
We test the three trees that \ty{drawSt} can draw: conventional
(Figure~\ref{fig:stConv}), interval (Figure~\ref{fig:stInt}), and
Newick (Figure~\ref{fig:stNwk}A). Every time we use the sequence
\ty{TTAAAATAT} with sentinel.
\nwenddocs{}\nwbegincode{144}\sublabel{NW0-4T8Qxp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4T8Qxp-1}}}\moddef{Construct tests, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4T8Qxp-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3pRrcD-1}}\nwenddeflinemarkup
file := "test.fasta"
cmd := exec.Command("./drawSt", "-s", file)
tests = append(tests, cmd)
cmd = exec.Command("./drawSt", "-s", "-i", file)
tests = append(tests, cmd)
cmd = exec.Command("./drawSt", "-s", "-n", file)
tests = append(tests, cmd)
\nwused{\\{NW0-3pRrcD-1}}\nwendcode{}\nwbegindocs{145}\nwdocspar
When running a test, we compare the output we get with the output we
want.
\nwenddocs{}\nwbegincode{146}\sublabel{NW0-41eGC9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-41eGC9-1}}}\moddef{Run test, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-41eGC9-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3pRrcD-1}}\nwenddeflinemarkup
get, err := test.Output()
if err != nil \{ t.Error(err.Error()) \}
file = "res" + strconv.Itoa(i+1) + ".txt"
want, err := ioutil.ReadFile(file)
if err != nil \{ t.Error(err.Error()) \}
if !bytes.Equal(get, want) \{
          t.Errorf("get:\\n%s\\nwant:\\n%s\\n",
                  string(get), string(want))
\}
\nwused{\\{NW0-3pRrcD-1}}\nwendcode{}\nwbegindocs{147}\nwdocspar
We import \ty{strconv}, \ty{ioutil}, and \ty{bytes}.
\nwenddocs{}\nwbegincode{148}\sublabel{NW0-4LVHpY-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4LVHpY-2}}}\moddef{Testing imports, Ch.~\ref{ch:dst}~{\nwtagstyle{}\subpageref{NW0-4LVHpY-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2WJytI-1}}\nwprevnextdefs{NW0-4LVHpY-1}{\relax}\nwenddeflinemarkup
"strconv"
"io/ioutil"
"bytes"
\nwused{\\{NW0-2WJytI-1}}\nwendcode{}

\nwixlogsorted{c}{{Add child to internal node, Ch.~\ref{ch:dst}}{NW0-1Jymm8-1}{\nwixu{NW0-1ETjx5-1}\nwixd{NW0-1Jymm8-1}}}%
\nwixlogsorted{c}{{Add leaves in the middle, Ch.~\ref{ch:dst}}{NW0-ybLGo-1}{\nwixu{NW0-1FIDSz-1}\nwixd{NW0-ybLGo-1}}}%
\nwixlogsorted{c}{{Add leaves on the left, Ch.~\ref{ch:dst}}{NW0-4VG5qB-1}{\nwixu{NW0-1FIDSz-1}\nwixd{NW0-4VG5qB-1}}}%
\nwixlogsorted{c}{{Add leaves on the right, Ch.~\ref{ch:dst}}{NW0-4R4gkk-1}{\nwixu{NW0-1FIDSz-1}\nwixd{NW0-4R4gkk-1}}}%
\nwixlogsorted{c}{{Add leaves, Ch.~\ref{ch:dst}}{NW0-1860vx-1}{\nwixu{NW0-2DUupi-1}\nwixd{NW0-1860vx-1}}}%
\nwixlogsorted{c}{{Add levels, Ch.~\ref{ch:dst}}{NW0-2LGuIG-1}{\nwixu{NW0-2DUupi-1}\nwixd{NW0-2LGuIG-1}}}%
\nwixlogsorted{c}{{Add sibling to internal node, Ch.~\ref{ch:dst}}{NW0-2UZ4T9-1}{\nwixu{NW0-1ETjx5-1}\nwixd{NW0-2UZ4T9-1}}}%
\nwixlogsorted{c}{{Branch length, Ch.~\ref{ch:dst}}{NW0-2zl6y7-1}{\nwixu{NW0-2wzOEh-B}\nwixd{NW0-2zl6y7-1}\nwixu{NW0-jJjnW-1}}}%
\nwixlogsorted{c}{{Compare parent interval to child intervals, Ch.~\ref{ch:dst}}{NW0-1FIDSz-1}{\nwixu{NW0-2wzOEh-5}\nwixd{NW0-1FIDSz-1}}}%
\nwixlogsorted{c}{{Compute suffix tree, Ch.~\ref{ch:dst}}{NW0-3rgVLJ-1}{\nwixu{NW0-3YShji-1}\nwixd{NW0-3rgVLJ-1}}}%
\nwixlogsorted{c}{{Construct tests, Ch.~\ref{ch:dst}}{NW0-4T8Qxp-1}{\nwixu{NW0-3pRrcD-1}\nwixd{NW0-4T8Qxp-1}}}%
\nwixlogsorted{c}{{Declare options, Ch.~\ref{ch:dst}}{NW0-2H6NhM-1}{\nwixu{NW0-2Ue6PL-1}\nwixd{NW0-2H6NhM-1}}}%
\nwixlogsorted{c}{{Draw suffix tree, Ch.~\ref{ch:dst}}{NW0-2DUupi-1}{\nwixu{NW0-3YShji-1}\nwixd{NW0-2DUupi-1}}}%
\nwixlogsorted{c}{{drawSt.go}{NW0-1Bt7tY-1}{\nwixd{NW0-1Bt7tY-1}}}%
\nwixlogsorted{c}{{drawSt\_test.go}{NW0-2WJytI-1}{\nwixd{NW0-2WJytI-1}}}%
\nwixlogsorted{c}{{Functions, Ch.~\ref{ch:dst}}{NW0-2wzOEh-1}{\nwixu{NW0-1Bt7tY-1}\nwixd{NW0-2wzOEh-1}\nwixd{NW0-2wzOEh-2}\nwixd{NW0-2wzOEh-3}\nwixd{NW0-2wzOEh-4}\nwixd{NW0-2wzOEh-5}\nwixd{NW0-2wzOEh-6}\nwixd{NW0-2wzOEh-7}\nwixd{NW0-2wzOEh-8}\nwixd{NW0-2wzOEh-9}\nwixd{NW0-2wzOEh-A}\nwixd{NW0-2wzOEh-B}}}%
\nwixlogsorted{c}{{Imports, Ch.~\ref{ch:dst}}{NW0-JyyYQ-1}{\nwixu{NW0-1Bt7tY-1}\nwixd{NW0-JyyYQ-1}\nwixd{NW0-JyyYQ-2}\nwixd{NW0-JyyYQ-3}\nwixd{NW0-JyyYQ-4}\nwixd{NW0-JyyYQ-5}\nwixd{NW0-JyyYQ-6}\nwixd{NW0-JyyYQ-7}\nwixd{NW0-JyyYQ-8}}}%
\nwixlogsorted{c}{{Insert child between siblings?, Ch.~\ref{ch:dst}}{NW0-1Sro03-1}{\nwixu{NW0-1GShJr-3}\nwixd{NW0-1Sro03-1}}}%
\nwixlogsorted{c}{{Insert child on the left of siblings?, Ch.~\ref{ch:dst}}{NW0-4M2Ra-1}{\nwixu{NW0-1GShJr-3}\nwixd{NW0-4M2Ra-1}}}%
\nwixlogsorted{c}{{Insert child on the right of siblings?, Ch.~\ref{ch:dst}}{NW0-3krEmu-1}{\nwixu{NW0-1GShJr-3}\nwixd{NW0-3krEmu-1}}}%
\nwixlogsorted{c}{{Is $i$ a leaf? Ch.~\ref{ch:dst}}{NW0-MgUMW-1}{\nwixu{NW0-2wzOEh-9}\nwixd{NW0-MgUMW-1}}}%
\nwixlogsorted{c}{{Is $i$ an internal node? Ch.~\ref{ch:dst}}{NW0-1ETjx5-1}{\nwixu{NW0-2wzOEh-9}\nwixd{NW0-1ETjx5-1}}}%
\nwixlogsorted{c}{{Is $v$ a leaf? Ch.~\ref{ch:dst}}{NW0-2BeTlA-1}{\nwixu{NW0-2wzOEh-A}\nwixd{NW0-2BeTlA-1}}}%
\nwixlogsorted{c}{{Is $v$ an internal node? Ch.~\ref{ch:dst}}{NW0-jJjnW-1}{\nwixu{NW0-2wzOEh-A}\nwixd{NW0-jJjnW-1}}}%
\nwixlogsorted{c}{{Is $v$ not a first child? Ch.~\ref{ch:dst}}{NW0-utcUk-1}{\nwixu{NW0-2wzOEh-A}\nwixd{NW0-utcUk-1}}}%
\nwixlogsorted{c}{{Is $v$ the root? Ch.~\ref{ch:dst}}{NW0-3HF8xA-1}{\nwixu{NW0-2wzOEh-A}\nwixd{NW0-3HF8xA-1}}}%
\nwixlogsorted{c}{{Iterate over sequences, Ch.~\ref{ch:dst}}{NW0-3YShji-1}{\nwixu{NW0-2wzOEh-1}\nwixd{NW0-3YShji-1}}}%
\nwixlogsorted{c}{{Label conventional node, Ch.~\ref{ch:dst}}{NW0-1ZT7jY-1}{\nwixu{NW0-2wzOEh-7}\nwixd{NW0-1ZT7jY-1}}}%
\nwixlogsorted{c}{{Main function, Ch.~\ref{ch:dst}}{NW0-2Ue6PL-1}{\nwixu{NW0-1Bt7tY-1}\nwixd{NW0-2Ue6PL-1}}}%
\nwixlogsorted{c}{{Methods, Ch.~\ref{ch:dst}}{NW0-1GShJr-1}{\nwixu{NW0-1Bt7tY-1}\nwixd{NW0-1GShJr-1}\nwixd{NW0-1GShJr-2}\nwixd{NW0-1GShJr-3}}}%
\nwixlogsorted{c}{{Open internal node, Ch.~\ref{ch:dst}}{NW0-1BUO31-1}{\nwixu{NW0-1ETjx5-1}\nwixd{NW0-1BUO31-1}}}%
\nwixlogsorted{c}{{Parse input files, Ch.~\ref{ch:dst}}{NW0-4CQUp5-1}{\nwixu{NW0-2Ue6PL-1}\nwixd{NW0-4CQUp5-1}}}%
\nwixlogsorted{c}{{Parse options, Ch.~\ref{ch:dst}}{NW0-3qXFXs-1}{\nwixu{NW0-2Ue6PL-1}\nwixd{NW0-3qXFXs-1}}}%
\nwixlogsorted{c}{{Place edge label, Ch.~\ref{ch:dst}}{NW0-3nKLIM-1}{\nwixu{NW0-4gPWgW-1}\nwixd{NW0-3nKLIM-1}}}%
\nwixlogsorted{c}{{Pop node, Ch.~\ref{ch:dst}}{NW0-3l6YnY-1}{\nwixu{NW0-3xidQP-1}\nwixd{NW0-3l6YnY-1}}}%
\nwixlogsorted{c}{{Prepare edge label, Ch.~\ref{ch:dst}}{NW0-4ES1xV-1}{\nwixu{NW0-4gPWgW-1}\nwixd{NW0-4ES1xV-1}}}%
\nwixlogsorted{c}{{Prepare sequence data, Ch.~\ref{ch:dst}}{NW0-1dW9kd-1}{\nwixu{NW0-3rgVLJ-1}\nwixd{NW0-1dW9kd-1}}}%
\nwixlogsorted{c}{{Print conventional tree, Ch.~\ref{ch:dst}}{NW0-29MzDO-1}{\nwixu{NW0-2DUupi-1}\nwixd{NW0-29MzDO-1}}}%
\nwixlogsorted{c}{{Print edge label, Ch.~\ref{ch:dst}}{NW0-4gPWgW-1}{\nwixu{NW0-2wzOEh-8}\nwixd{NW0-4gPWgW-1}}}%
\nwixlogsorted{c}{{Print interval tree, Ch.~\ref{ch:dst}}{NW0-2dbD1x-1}{\nwixu{NW0-2DUupi-1}\nwixd{NW0-2dbD1x-1}}}%
\nwixlogsorted{c}{{Print Newick tree, Ch.~\ref{ch:dst}}{NW0-2HrrqA-1}{\nwixu{NW0-2DUupi-1}\nwixd{NW0-2HrrqA-1}}}%
\nwixlogsorted{c}{{Push node, Ch.~\ref{ch:dst}}{NW0-26fkIe-1}{\nwixu{NW0-3xidQP-1}\nwixd{NW0-26fkIe-1}}}%
\nwixlogsorted{c}{{Retrieve conventional node arguments, Ch.~\ref{ch:dst}}{NW0-1SBw8M-1}{\nwixu{NW0-2wzOEh-7}\nwixd{NW0-1SBw8M-1}}}%
\nwixlogsorted{c}{{Retrieve options, Ch.~\ref{ch:dst}}{NW0-3vLqZ0-1}{\nwixu{NW0-2wzOEh-1}\nwixd{NW0-3vLqZ0-1}}}%
\nwixlogsorted{c}{{Run test, Ch.~\ref{ch:dst}}{NW0-41eGC9-1}{\nwixu{NW0-3pRrcD-1}\nwixd{NW0-41eGC9-1}}}%
\nwixlogsorted{c}{{Set usage, Ch.~\ref{ch:dst}}{NW0-3QNT53-1}{\nwixu{NW0-2Ue6PL-1}\nwixd{NW0-3QNT53-1}}}%
\nwixlogsorted{c}{{Testing imports, Ch.~\ref{ch:dst}}{NW0-4LVHpY-1}{\nwixu{NW0-2WJytI-1}\nwixd{NW0-4LVHpY-1}\nwixd{NW0-4LVHpY-2}}}%
\nwixlogsorted{c}{{Testing logic, Ch.~\ref{ch:dst}}{NW0-3pRrcD-1}{\nwixu{NW0-2WJytI-1}\nwixd{NW0-3pRrcD-1}}}%
\nwixlogsorted{c}{{Traverse lcp array, Ch.~\ref{ch:dst}}{NW0-3xidQP-1}{\nwixu{NW0-3rgVLJ-1}\nwixd{NW0-3xidQP-1}}}%
\nwixlogsorted{c}{{Types, Ch.~\ref{ch:dst}}{NW0-2NSCiL-1}{\nwixu{NW0-1Bt7tY-1}\nwixd{NW0-2NSCiL-1}\nwixd{NW0-2NSCiL-2}\nwixd{NW0-2NSCiL-3}}}%
\nwixlogsorted{c}{{Variables, Ch.~\ref{ch:dst}}{NW0-1ssEPz-1}{\nwixu{NW0-1Bt7tY-1}\nwixd{NW0-1ssEPz-1}}}%
\nwixlogsorted{c}{{Write conventional node, Ch.~\ref{ch:dst}}{NW0-1umSmz-1}{\nwixu{NW0-2wzOEh-7}\nwixd{NW0-1umSmz-1}}}%

