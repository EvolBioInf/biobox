\nwfilename{}\nwbegindocs{0}\nwenddocs{}\nwbegindocs{1}\nwdocspar% ===> this file was generated automatically by noweave --- better not edit it
\section*{Introduction}
Our aim is to count the residues in sequences. What we in fact do, is
to count the characters in sequences, without checking whether they
are residues or not.
\section*{Implementation}
The program outline contains hooks for imports, variables, functions,
and the meat of the main function.
\nwenddocs{}\nwbegincode{2}\sublabel{NW0-3Ni8Yu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3Ni8Yu-1}}}\moddef{cchar.go~{\nwtagstyle{}\subpageref{NW0-3Ni8Yu-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
package main

import (
          \LA{}Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}\RA{}
)

\LA{}Variables, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-1qf9Wr-1}}\RA{}
\LA{}Functions, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2zJtuX-1}}\RA{}
func main() \{
          \LA{}Main function, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2WrDLN-1}}\RA{}
\}
\nwnotused{cchar.go}\nwendcode{}\nwbegindocs{3}\nwdocspar
In the \texttt{main} function we first set the usage, then parse the
options set by the user, and finally the input.
\nwenddocs{}\nwbegincode{4}\sublabel{NW0-2WrDLN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2WrDLN-1}}}\moddef{Main function, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2WrDLN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwenddeflinemarkup
\LA{}Set usage, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-3OBXpn-1}}\RA{}
\LA{}Parse options, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-3oBPzO-1}}\RA{}
\LA{}Parse input, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2aqsG5-1}}\RA{}
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{5}\nwdocspar
In addition to the usage, we describe the purpose and give an example
command.
\nwenddocs{}\nwbegincode{6}\sublabel{NW0-3OBXpn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3OBXpn-1}}}\moddef{Set usage, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-3OBXpn-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2WrDLN-1}}\nwenddeflinemarkup
u := "cchar [-h] [options] [files]"
p := "Count characters in input."
e := "cchar -s *.fasta"
clio.Usage(u, p, e)
\nwused{\\{NW0-2WrDLN-1}}\nwendcode{}\nwbegindocs{7}\nwdocspar
We import \texttt{clio}.
\nwenddocs{}\nwbegincode{8}\sublabel{NW0-MBlFE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\moddef{Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{\relax}{NW0-MBlFE-2}\nwenddeflinemarkup
"github.com/evolbioinf/clio"
\nwalsodefined{\\{NW0-MBlFE-2}\\{NW0-MBlFE-3}\\{NW0-MBlFE-4}\\{NW0-MBlFE-5}\\{NW0-MBlFE-6}\\{NW0-MBlFE-7}}\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{9}\nwdocspar
The user can request that each sequence is counted separately,
\texttt{-s}. There is also the possibility to just print the version
and additional information about the program, \texttt{-v}.
\nwenddocs{}\nwbegincode{10}\sublabel{NW0-1qf9Wr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1qf9Wr-1}}}\moddef{Variables, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-1qf9Wr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{\relax}{NW0-1qf9Wr-2}\nwenddeflinemarkup
var optS = flag.Bool("s", false, "count sequences separately")
var optV = flag.Bool("v", false, "print version & " +
          "program information")
\nwalsodefined{\\{NW0-1qf9Wr-2}}\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{11}\nwdocspar
This requires the \texttt{flag} package.
\nwenddocs{}\nwbegincode{12}\sublabel{NW0-MBlFE-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MBlFE-2}}}\moddef{Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-MBlFE-1}{NW0-MBlFE-3}\nwenddeflinemarkup
"flag"
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{13}\nwdocspar
After parsing the flags, the program might just print
its version.
\nwenddocs{}\nwbegincode{14}\sublabel{NW0-3oBPzO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3oBPzO-1}}}\moddef{Parse options, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-3oBPzO-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2WrDLN-1}}\nwenddeflinemarkup
flag.Parse()
if *optV \{
          util.PrintInfo("cchar")
\}
\nwused{\\{NW0-2WrDLN-1}}\nwendcode{}\nwbegindocs{15}\nwdocspar
We import the package \texttt{util}.
\nwenddocs{}\nwbegincode{16}\sublabel{NW0-MBlFE-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MBlFE-3}}}\moddef{Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-MBlFE-2}{NW0-MBlFE-4}\nwenddeflinemarkup
"github.com/evolbioinf/biobox/util"
"os"
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{17}\nwdocspar
The values of \texttt{version} and \texttt{date} are injected at
compile-time. Here, we just declare them.
\nwenddocs{}\nwbegincode{18}\sublabel{NW0-1qf9Wr-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-1qf9Wr-2}}}\moddef{Variables, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-1qf9Wr-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-1qf9Wr-1}{\relax}\nwenddeflinemarkup
var version, date string
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{19}\nwdocspar
The input files are parsed using \texttt{clio.ParseFiles}, which takes
as argument a slice of file names and a function it applies to each
file. This function takes as arguments the character counts, and an
indicator as to whether or not it is dealing with the first
sequence. At the end, \texttt{write} prints the counts.  Characters
are encoded as bytes that are eight bits long. So \texttt{counts} is a
slice of $2^8=256$ long integers.
\nwenddocs{}\nwbegincode{20}\sublabel{NW0-2aqsG5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2aqsG5-1}}}\moddef{Parse input, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2aqsG5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2WrDLN-1}}\nwenddeflinemarkup
files := flag.Args()
counts := make([]int64, 256)
isFirstSequence := true
clio.ParseFiles(files, scan, counts, *optS, &isFirstSequence)
write(counts, *optS)
\nwused{\\{NW0-2WrDLN-1}}\nwendcode{}\nwbegindocs{21}\nwdocspar
We import \texttt{clio}.
\nwenddocs{}\nwbegincode{22}\sublabel{NW0-MBlFE-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MBlFE-4}}}\moddef{Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-MBlFE-3}{NW0-MBlFE-5}\nwenddeflinemarkup
"github.com/evolbioinf/clio"
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{23}\nwdocspar
Before scanning a file, the arguments are retrieved. Then the data is
scanned line-wise. Each line is either a header or consists of
characters to be counted.
\nwenddocs{}\nwbegincode{24}\sublabel{NW0-2zJtuX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2zJtuX-1}}}\moddef{Functions, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2zJtuX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{\relax}{NW0-2zJtuX-2}\nwenddeflinemarkup
func scan(r io.Reader, args ...interface\{\}) \{
          \LA{}Retrieve arguments, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-11786S-1}}\RA{}
          scanner := fasta.NewScanner(r)
          for scanner.ScanLine() \{
                  if scanner.IsHeader() \{
                          \LA{}Deal with header, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-4BNutl-1}}\RA{}
                  \} else \{
                          count(counts, scanner.Line())
                  \}
          \}
\}
\nwalsodefined{\\{NW0-2zJtuX-2}\\{NW0-2zJtuX-3}\\{NW0-2zJtuX-4}}\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{25}\nwdocspar
Import \texttt{io} and \texttt{fasta}.
\nwenddocs{}\nwbegincode{26}\sublabel{NW0-MBlFE-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MBlFE-5}}}\moddef{Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-MBlFE-4}{NW0-MBlFE-6}\nwenddeflinemarkup
"io"
"github.com/evolbioinf/fasta"
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{27}\nwdocspar
As we saw above, \texttt{args} contains two arguments: the integer
slice of counts, and the pointer to a boolean indicating whether or
not we are dealing with the first sequence. We retrieve them by type
assertions~\cite[p. 205]{don16:go}.
\nwenddocs{}\nwbegincode{28}\sublabel{NW0-11786S-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-11786S-1}}}\moddef{Retrieve arguments, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-11786S-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2zJtuX-1}}\nwenddeflinemarkup
counts := args[0].([]int64)
separate := args[1].(bool)
isFirstSequence := args[2].(*bool)
\nwused{\\{NW0-2zJtuX-1}}\nwendcode{}\nwbegindocs{29}\nwdocspar
The response to encountering a header depends on whether the user has
requested separate counts for each sequence. If not, we do nothing. If
yes, we print and reset counts whenever a header closes a sequence.
\nwenddocs{}\nwbegincode{30}\sublabel{NW0-4BNutl-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4BNutl-1}}}\moddef{Deal with header, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-4BNutl-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2zJtuX-1}}\nwenddeflinemarkup
if separate \{
          if *isFirstSequence \{
                  *isFirstSequence = false
          \} else \{
                  write(counts, *optS)
                  reset(counts)
          \}
          fmt.Printf("%s: ", scanner.Line())
\}
\nwused{\\{NW0-2zJtuX-1}}\nwendcode{}\nwbegindocs{31}\nwdocspar
The function \texttt{write} prints the total number of characters, and
their individual counts and frequencies.
\nwenddocs{}\nwbegincode{32}\sublabel{NW0-2zJtuX-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2zJtuX-2}}}\moddef{Functions, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2zJtuX-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-2zJtuX-1}{NW0-2zJtuX-3}\nwenddeflinemarkup
func write(counts []int64, separate bool) \{
          \LA{}Print total character count, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-3hSpry-1}}\RA{}
          \LA{}Print individual counts, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-4Wix1x-1}}\RA{}
\}
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{33}\nwdocspar
We sum the individual character counts and print them either in ``separate''
or ``total'' mode.
\nwenddocs{}\nwbegincode{34}\sublabel{NW0-3hSpry-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-3hSpry-1}}}\moddef{Print total character count, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-3hSpry-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2zJtuX-2}}\nwenddeflinemarkup
var s int64
for \_, v := range counts \{
          s += v
\}
if !separate \{
          fmt.Printf("Total: ")
\}
fmt.Printf("%d\\n", s)
\nwused{\\{NW0-2zJtuX-2}}\nwendcode{}\nwbegindocs{35}\nwdocspar
We import \texttt{fmt}.
\nwenddocs{}\nwbegincode{36}\sublabel{NW0-MBlFE-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MBlFE-6}}}\moddef{Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-MBlFE-5}{NW0-MBlFE-7}\nwenddeflinemarkup
"fmt"
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{37}\nwdocspar
If any characters were found, we print the individual counts and
frequencies in a table formatted using a \texttt{tabwriter}.
\nwenddocs{}\nwbegincode{38}\sublabel{NW0-4Wix1x-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4Wix1x-1}}}\moddef{Print individual counts, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-4Wix1x-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2zJtuX-2}}\nwenddeflinemarkup
w := new(tabwriter.Writer)
w.Init(os.Stdout, 4, 0, 1, ' ', 0)
if s > 0 \{
          fmt.Fprintf(w, "Character\\tCount\\tFraction\\t\\n")
\}
for i, v := range counts \{
          if v > 0 \{
                  fmt.Fprintf(w, "%c\\t%d\\t%g\\t\\n", i, v,
                          float64(v)/float64(s))
          \}
\}
w.Flush()
\nwused{\\{NW0-2zJtuX-2}}\nwendcode{}\nwbegindocs{39}\nwdocspar
Import the \texttt{tabwriter} package.
\nwenddocs{}\nwbegincode{40}\sublabel{NW0-MBlFE-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-MBlFE-7}}}\moddef{Imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-MBlFE-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-MBlFE-6}{\relax}\nwenddeflinemarkup
"text/tabwriter"
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{41}\nwdocspar
We reset the \texttt{counts}.
\nwenddocs{}\nwbegincode{42}\sublabel{NW0-2zJtuX-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2zJtuX-3}}}\moddef{Functions, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2zJtuX-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-2zJtuX-2}{NW0-2zJtuX-4}\nwenddeflinemarkup
func reset(counts []int64) \{
          for i, \_ := range counts \{
                  counts[i] = 0
          \}
\}
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{43}\nwdocspar
When we at last count the characters, they serve as indexes into the
integer slice \texttt{counts}.
\nwenddocs{}\nwbegincode{44}\sublabel{NW0-2zJtuX-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2zJtuX-4}}}\moddef{Functions, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-2zJtuX-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-3Ni8Yu-1}}\nwprevnextdefs{NW0-2zJtuX-3}{\relax}\nwenddeflinemarkup
func count(counts []int64, data []byte) \{
          for \_, c := range data \{
                  counts[c]++
          \}
\}
\nwused{\\{NW0-3Ni8Yu-1}}\nwendcode{}\nwbegindocs{45}\nwdocspar
\section*{Testing}
We use the standard testing framework.
\nwenddocs{}\nwbegincode{46}\sublabel{NW0-2znUat-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-2znUat-1}}}\moddef{cchar\_test.go~{\nwtagstyle{}\subpageref{NW0-2znUat-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
package main
import (
          "testing"
          \LA{}Testing imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-4Ni3SM-1}}\RA{}
)
func TestCchar(t *testing.T) \{
          \LA{}Testing, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-t5Any-1}}\RA{}
\}
\nwnotused{cchar\_test.go}\nwendcode{}\nwbegindocs{47}\nwdocspar
Our test is carried out on the file \texttt{test.fasta}, which
contains two random sequences, each 100 nucleotides long. We first run
\texttt{cchar} with default options and compare the result with that
contained in the file \texttt{res1.txt}.
\nwenddocs{}\nwbegincode{48}\sublabel{NW0-t5Any-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-t5Any-1}}}\moddef{Testing, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-t5Any-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2znUat-1}}\nwprevnextdefs{\relax}{NW0-t5Any-2}\nwenddeflinemarkup
cmd := exec.Command("cchar", "test.fasta")
o, err := cmd.Output()
if err != nil \{
          t.Errorf("couldn't run %q\\n", cmd)
\}
e, err := ioutil.ReadFile("res1.txt")
if err != nil \{
          t.Error("couldn't open res1.txt")
\}
if !bytes.Equal(o, e) \{
          t.Errorf("wanted:\\n%s\\ngot:\\n%s\\n", string(e), string(o))
\}
\nwalsodefined{\\{NW0-t5Any-2}}\nwused{\\{NW0-2znUat-1}}\nwendcode{}\nwbegindocs{49}\nwdocspar
We import \texttt{exec}, \texttt{ioutil}, and \texttt{bytes}.
\nwenddocs{}\nwbegincode{50}\sublabel{NW0-4Ni3SM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-4Ni3SM-1}}}\moddef{Testing imports, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-4Ni3SM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2znUat-1}}\nwenddeflinemarkup
"os/exec"
"io/ioutil"
"bytes"
\nwused{\\{NW0-2znUat-1}}\nwendcode{}\nwbegindocs{51}\nwdocspar
There is only one option to test, \texttt{-s} for counting sequences
separately. This time, we compare the result to that contained in the
file \texttt{res2.txt}.
\nwenddocs{}\nwbegincode{52}\sublabel{NW0-t5Any-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW0-t5Any-2}}}\moddef{Testing, Ch.~\ref{ch:cch}~{\nwtagstyle{}\subpageref{NW0-t5Any-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW0-2znUat-1}}\nwprevnextdefs{NW0-t5Any-1}{\relax}\nwenddeflinemarkup
cmd = exec.Command("cchar", "-s", "test.fasta")
o, err = cmd.Output()
if err != nil \{
          t.Errorf("couldn't run %q\\n", cmd)
\}
e, err = ioutil.ReadFile("res2.txt")
if err != nil \{
          t.Error("couldn't open res2.txt")
\}
if !bytes.Equal(o, e) \{
          t.Errorf("wanted:\\n%s\\ngot:\\n%s\\n", string(e), string(o))
\}
\nwused{\\{NW0-2znUat-1}}\nwendcode{}

\nwixlogsorted{c}{{cchar.go}{NW0-3Ni8Yu-1}{\nwixd{NW0-3Ni8Yu-1}}}%
\nwixlogsorted{c}{{cchar\_test.go}{NW0-2znUat-1}{\nwixd{NW0-2znUat-1}}}%
\nwixlogsorted{c}{{Deal with header, Ch.~\ref{ch:cch}}{NW0-4BNutl-1}{\nwixu{NW0-2zJtuX-1}\nwixd{NW0-4BNutl-1}}}%
\nwixlogsorted{c}{{Functions, Ch.~\ref{ch:cch}}{NW0-2zJtuX-1}{\nwixu{NW0-3Ni8Yu-1}\nwixd{NW0-2zJtuX-1}\nwixd{NW0-2zJtuX-2}\nwixd{NW0-2zJtuX-3}\nwixd{NW0-2zJtuX-4}}}%
\nwixlogsorted{c}{{Imports, Ch.~\ref{ch:cch}}{NW0-MBlFE-1}{\nwixu{NW0-3Ni8Yu-1}\nwixd{NW0-MBlFE-1}\nwixd{NW0-MBlFE-2}\nwixd{NW0-MBlFE-3}\nwixd{NW0-MBlFE-4}\nwixd{NW0-MBlFE-5}\nwixd{NW0-MBlFE-6}\nwixd{NW0-MBlFE-7}}}%
\nwixlogsorted{c}{{Main function, Ch.~\ref{ch:cch}}{NW0-2WrDLN-1}{\nwixu{NW0-3Ni8Yu-1}\nwixd{NW0-2WrDLN-1}}}%
\nwixlogsorted{c}{{Parse input, Ch.~\ref{ch:cch}}{NW0-2aqsG5-1}{\nwixu{NW0-2WrDLN-1}\nwixd{NW0-2aqsG5-1}}}%
\nwixlogsorted{c}{{Parse options, Ch.~\ref{ch:cch}}{NW0-3oBPzO-1}{\nwixu{NW0-2WrDLN-1}\nwixd{NW0-3oBPzO-1}}}%
\nwixlogsorted{c}{{Print individual counts, Ch.~\ref{ch:cch}}{NW0-4Wix1x-1}{\nwixu{NW0-2zJtuX-2}\nwixd{NW0-4Wix1x-1}}}%
\nwixlogsorted{c}{{Print total character count, Ch.~\ref{ch:cch}}{NW0-3hSpry-1}{\nwixu{NW0-2zJtuX-2}\nwixd{NW0-3hSpry-1}}}%
\nwixlogsorted{c}{{Retrieve arguments, Ch.~\ref{ch:cch}}{NW0-11786S-1}{\nwixu{NW0-2zJtuX-1}\nwixd{NW0-11786S-1}}}%
\nwixlogsorted{c}{{Set usage, Ch.~\ref{ch:cch}}{NW0-3OBXpn-1}{\nwixu{NW0-2WrDLN-1}\nwixd{NW0-3OBXpn-1}}}%
\nwixlogsorted{c}{{Testing imports, Ch.~\ref{ch:cch}}{NW0-4Ni3SM-1}{\nwixu{NW0-2znUat-1}\nwixd{NW0-4Ni3SM-1}}}%
\nwixlogsorted{c}{{Testing, Ch.~\ref{ch:cch}}{NW0-t5Any-1}{\nwixu{NW0-2znUat-1}\nwixd{NW0-t5Any-1}\nwixd{NW0-t5Any-2}}}%
\nwixlogsorted{c}{{Variables, Ch.~\ref{ch:cch}}{NW0-1qf9Wr-1}{\nwixu{NW0-3Ni8Yu-1}\nwixd{NW0-1qf9Wr-1}\nwixd{NW0-1qf9Wr-2}}}%

