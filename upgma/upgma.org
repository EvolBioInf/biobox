#+begin_src latex
  \section*{Introduction}
  Of the many methods available for phylogeny reconstruction, distance
  methods are perhaps the simplest. The program \ty{upgma} implements
  the simplest among those, UPGMA~\cite[Ch. 10.3]{ohl13:bio}. Input is a
  distance matrix in PHYLIP format for example the one shown in
  (Figure~\ref{fig:upgma}A). For this, \ty{upgma} returns either the
  tree in Figure~\ref{fig:upgma}B. Upon request, \ty{upgma} also prints
  the intermediate distance matrices generated by this algorithm.

  \begin{figure}
    \begin{center}
      \begin{tabular}{cc}
	\textbf{A} & \textbf{B}\\
	\input{dm}
	&
	\scalebox{0.5}{\includegraphics{upgma}}
      \end{tabular}
    \end{center}
    \caption{A distance matrix (\textbf{A}) gets converted by
      \ty{upgma} into a UPGMA tree (\textbf{B}); tree plotted with
      \ty{plotTree}.}\label{fig:upgma}
  \end{figure}

  \section*{Implementation}
  The outline of \ty{upgma} contains hooks for imports, functions,
  and the logic of the main function.
#+end_src
#+begin_src go <<upgma.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:upgma}>>
  )
  //<<Functions, Ch.~\ref{ch:upgma}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:upgma}>>
  }
#+end_src
#+begin_src latex
  In the main function, we set the usage, declare the options, parse the
  options, and scan the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:upgma}>>=
  //<<Set usage, Ch.~\ref{ch:upgma}>>
  //<<Declare options, Ch.~\ref{ch:upgma}>>
  //<<Parse options, Ch.~\ref{ch:upgma}>>
  //<<Scan input files, Ch.~\ref{ch:upgma}>>
#+end_src
#+begin_src latex
  The usage consists of the actual usage message, an explanation of the
  purpose of \ty{upgma}, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:upgma}>>=
  u := "upgma [-h] [option]... [foo.dist]..."
  p := "Cluster a distance matrix into a tree using UPGMA."
  e := "upgma foo.dist"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:upgma}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the version (\ty{-v}), we declare an option for printing
  the intermediate matrices (\ty{-m}).
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:upgma}>>=
  var optV = flag.Bool("v", false, "version")
  var optM = flag.Bool("m", false, "print intermediate " +
	  "matrices")
#+end_src
#+begin_src latex
  We include \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:upgma}>>=
  "flag"
#+end_src
#+begin_src latex
  We parse the options and respond to \ty{-v}, as this terminates the
  program.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:upgma}>>=
  flag.Parse()
  if *optV {
	  util.PrintInfo("upgma")
  }
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:upgma}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_src latex
  The remaining tokens on the command line are interpreted as file
  names. We scan each file with the function \ty{scan}, which takes as
  arguments the two options that influence tree computation, \ty{-u} and
  \ty{-m}.
#+end_src
#+begin_src go <<Scan input files, Ch.~\ref{ch:upgma}>>=
  files := flag.Args()
  clio.ParseFiles(files, scan, *optM)
#+end_src
#+begin_src latex
  Inside \ty{scan}, we retrieve the option just passed, and iterate over
  the distance matrices in the input.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:upgma}>>=
  func scan(r io.Reader, args ...interface{}) {
	  printMat := args[0].(bool)
	  sc := dist.NewScanner(r)
	  for sc.Scan() {
		  dm := sc.DistanceMatrix()
		  //<<Process distance matrix, Ch.~\ref{ch:upgma}>>
	  }
  }
#+end_src
#+begin_src latex
  We import \ty{io} and \ty{dist}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:upgma}>>=
  "io"
  "github.com/evolbioinf/dist"
#+end_src
#+begin_src latex
  The first step to process a distance matrix is to make it symmetrical
  and to store its dimension. Then the matrix is converted into a tree,
  represented by its root, and printed.
#+end_src
#+begin_src go <<Process distance matrix, Ch.~\ref{ch:upgma}>>=
  dm.MakeSymmetrical()
  n := len(dm.Names)
  var root *nwk.Node
  <<Calculate tree, Ch.~\ref{ch:upgma}>>
  fmt.Println(root)
#+end_src
#+begin_src latex
  We import \ty{nwk} and \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:upgma}>>=
  "github.com/evolbioinf/nwk"
  "fmt"
#+end_src
#+begin_src latex
  We calculate the tree using two data structures: Our $n\times n$
  distance matrix, $d$, and an array of $n$ tree nodes, $t$. Tree
  construction consists of picking pairs of children from $t$ and
  clustering them in parent nodes, $r$. A pair of children $i,j$, has
  the smallest entry in $d$, and the height of their parent is
  $d_{ij}/2$.

  The children are removed from $d$ and from $t$, and replaced by $r$,
  so a parent becomes a child in the next round.

  The distance between $r$ and the remaining nodes, $k$, is the average
  distance to the children clustered:
  \[
  d_{rk}=(d_{ki}+d_{kj})/2.
  \]
  After the last round, $r$ is the root of the desired tree.
  Algorithm~\ref{alg:upgma} summarizes these steps.
  \begin{algorithm}
    \caption{The UPGMA clustering algorithm.}\label{alg:upgma}
    \input{upgmaAlg}
  \end{algorithm}

  When we calculate a tree, we begin by constructing the node
  array. Then we iterate until the node array contains only two
  entries. In each iteration, we might print the distance matrix, if so
  desired. Then we pick a pair of nodes, cluster them, and replace
  them. Once the tree has been constructed, we convert the node heights
  to branch lengths.
#+end_src
#+begin_src go <<Calculate tree, Ch.~\ref{ch:upgma}>>=
  //<<Construct node array, Ch.~\ref{ch:upgma}>>
  for i := n; i > 1; i-- {
	  if printMat {
		  fmt.Printf("%s", dm)
	  }
	  //<<Pick nodes to be clustered, Ch.~\ref{ch:upgma}>>
	  //<<Cluster nodes, Ch.~\ref{ch:upgma}>>
	  //<<Replace clustered nodes, Ch.~\ref{ch:upgma}>>
  }
  //<<Convert node heights to branch lengths, Ch.~\ref{ch:upgma}>>
#+end_src
#+begin_src latex
  The node array initially consists of $n$ leaves.
#+end_src
#+begin_src go <<Construct node array, Ch.~\ref{ch:upgma}>>=
  t := make([]*nwk.Node, n)
  for i := 0; i < n; i++ {
	  t[i] = nwk.NewNode()
	  t[i].Label = dm.Names[i]
  }
#+end_src
#+begin_src latex
  By finding the minimum matrix entry, we find the nodes to be
  clustered.
#+end_src
#+begin_src go <<Pick nodes to be clustered, Ch.~\ref{ch:upgma}>>=
  md, mj, mk := dm.Min()
  c1 := t[mj]
  c2 := t[mk]
  root = nwk.NewNode()
  l := fmt.Sprintf("(%s,%s)", c1.Label, c2.Label)
  root.Label = l
  root.Length = md / 2
#+end_src
#+begin_src latex
  We cluster the nodes by adding nodes \ty{c1} and \ty{c2} as children
  of \ty{root}.
#+end_src
#+begin_src go <<Cluster nodes, Ch.~\ref{ch:upgma}>>=
  root.AddChild(c1)
  root.AddChild(c2)
#+end_src
#+begin_src latex
  We replace the matrix entries and the entries in the nodes array.
#+end_src
#+begin_src go <<Replace clustered nodes, Ch.~\ref{ch:upgma}>>=
  //<<Replace matrix entries, Ch.~\ref{ch:upgma}>>
  //<<Replace entries in node array, Ch.~\ref{ch:upgma}>>
#+end_src
#+begin_src latex
  We replace the matrix entries by computing the distances between the
  new node and all other nodes. Then we delete the child nodes from the
  distance matrix and replace them by appending the new distances. The
  label of the new cluster is constructed from the labels of its
  children.
#+end_src
#+begin_src go <<Replace matrix entries, Ch.~\ref{ch:upgma}>>=
  data := make([]float64, i-2)
  k := 0
  for j := 0; j < i; j++ {
	  if j == mj || j == mk { continue }
	  data[k] = (dm.Matrix[j][mj] + dm.Matrix[j][mk]) / 2.0
	  k++
  }
  dm.DeletePair(mj, mk)
  dm.Append(root.Label, data)
#+end_src
#+begin_src latex
  We remove the nodes picked from the node array and append the current
  root.
#+end_src
#+begin_src go <<Replace entries in node array, Ch.~\ref{ch:upgma}>>=
  j := 0
  for k := 0; k < i; k++ {
	  if k == mj || k == mk { continue }
	  t[j] = t[k]
	  j++
  }
  t = t[:j]
  t = append(t, root)
#+end_src
#+begin_src latex
  What remains, is to convert the node heights into branch lengths. We
  do this by calling a function for tree traversal. In this step we also
  remove the node labels again, as they were only useful for printing
  the matrix. In the actual phylogeny, only the leaves have labels.
#+end_src
#+begin_src go <<Convert node heights to branch lengths, Ch.~\ref{ch:upgma}>>=
  branchLengths(root)
#+end_src
#+begin_src latex
  Branch lengths are computed by subtracting the height of the child
  from that of the parent. Let's also not forget to reset the labels of
  internal nodes.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:upgma}>>=
  func branchLengths(v *nwk.Node) {
	  if v == nil { return }
	  branchLengths(v.Child)
	  branchLengths(v.Sib)
	  if v.Child != nil { v.Label = "" }
	  if v.Parent != nil {
		  v.Length = v.Parent.Length - v.Length
		  v.HasLength = true
	  }
  }
#+end_src
#+begin_src latex
  The program \ty{upgma} is finished, time to test it.
  \section*{Testing}
  The outline of our testing code has hooks for imports and the testing
  logic.
#+end_src
#+begin_src go <<upgma_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:upgma}>>
  )

  func TestUpgma(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:upgma}>>
  }
#+end_src
#+begin_src latex
  We test our program by running it on the distance matrix shown in
  Figure~\ref{fig:upgma}A, which is contained in the file
  \texttt{test.phy}. Then we compare the output we get with the output
  we want, which is stored in the file \ty{r.txt}.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:upgma}>>=
  cmd := exec.Command("./upgma", "-m", "test.phy")
  get, err := cmd.Output()
  if err != nil {
	  t.Errorf("can't run %q", cmd)
  }
  want, err := ioutil.ReadFile("r.txt")
  if err != nil {
	  t.Errorf("can't open r.txt")
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_src latex
  We import \ty{exec}, \ty{ioutil}, and \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:upgma}>>=
  "os/exec"
  "io/ioutil"
  "bytes"
#+end_src
