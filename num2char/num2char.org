#+begin_src latex
  \section*{Introduction}
  The program \ty{mtf} creates a stream of numbers under the move to
  front algorithm. This output makes it easy to trace the move to front
  method, but difficult for character-based programs to parse the
  result. The program \ty{num2char} bridges this gap by translating the
  numbers 0--127 into letters and digits. The numbers are presented in
  the FASTA format generated by the program \ty{mtf}. For example, the
  input
  \begin{verbatim}
  >example - mtf
  2 1 3 2 1 1 3 0 0 2 3 3 0 2 1 1 1 1 3 0
  \end{verbatim}
  is converted by \ty{num2char} into
  \begin{verbatim}
  >example - mtf - num2char
  #"$#""$!!#$$!#""""$!
  \end{verbatim}
  \ty{num2char} can also reverse this step by decoding characters into
  numbers.

  \section*{Implementation}
  The implementation of \ty{mtf} has hooks for imports, functions, and
  the logic of the main function.
#+end_src
#+begin_src go <<num2char.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:n2c}>>
  )
  //<<Functions, Ch.~\ref{ch:n2c}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:n2c}>>
  }
#+end_src
#+begin_src latex
  In the main function we prepare the \ty{log} package, set the usage,
  declare the options, parse the options, and parse the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:n2c}>>=
  util.PrepLog("num2char")
  //<<Set usage, Ch.~\ref{ch:n2c}>>
  //<<Declare options, Ch.~\ref{ch:n2c}>>
  //<<Parse options, Ch.~\ref{ch:n2c}>>
  //<<Parse input files, Ch.~\ref{ch:n2c}>>
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_src latex
  The usage consists of the actual usage message, an explanation of the
  purpose of \ty{num2char}, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:n2c}>>=
  u := "num2char [-h] [option]... [file]..."
  p := "Convert FASTA-formatted numbers 0-127 to " +
	  "printable characters."
  e := "mtf foo.fasta | num2char"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  We declare an option for printing the version (\ty{-v}) and an option
  for decoding characters into numbers (\ty{-d}).
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:n2c}>>=
  var optV = flag.Bool("v", false, "version")
  var optD = flag.Bool("d", false, "decode")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "flag"
#+end_src
#+begin_src latex
  We parse the two options and respond to \ty{-v} first, as this would
  stop the program. Then we construct the encoding dictionary. If the
  user chose decoding, we convert the encoding dictionary into its
  decoding version.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:n2c}>>=
  flag.Parse()
  dict := make(map[string]string)
  if *optV {
	  util.PrintInfo("num2char")
  }
  //<<Construct encoding dictionary, Ch.~\ref{ch:n2c}>>
  if *optD {
	  //<<Construct decoding dictionary, Ch.~\ref{ch:n2c}>>
  }
#+end_src
#+begin_src latex
  In the encoding dictionary we map string representations of the
  numbers 0--127 to letters and digits
#+end_src
#+begin_src go <<Construct encoding dictionary, Ch.~\ref{ch:n2c}>>=
  j := 0
  for i := 0; i < 128; i++ {
	  for i+j < 256 {
		  r := rune(i + j)
		  if unicode.IsLetter(r) || unicode.IsDigit(r) {
			  dict[strconv.Itoa(i)] = string(r)
			  break
		  }
		  j++
	  }
  }
#+end_src
#+begin_src latex
  We import \ty{unicode} and \ty{strconv}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "unicode"
  "strconv"
#+end_src
#+begin_src latex
  In the decoding dictionary the values of the encoding dictionary are
  mapped onto its keys.
#+end_src
#+begin_src go <<Construct decoding dictionary, Ch.~\ref{ch:n2c}>>=
  nd := make(map[string]string)
  for i := 0; i < 128; i++ {
	  s := strconv.Itoa(i)
	  nd[dict[s]] = s
  }
  dict = nd
#+end_src
#+begin_src latex
  The remaining tokens on the command line are interpreted as the names
  of input files. These are parsed with the function \ty{scan}, which
  also takes the \ty{-d} option and the dictionary as arguments.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:n2c}>>=
  files := flag.Args()
  clio.ParseFiles(files, scan, *optD, dict)
#+end_src
#+begin_src latex
  Inside \ty{scan}, we retrieve the \ty{-d} option through type
  assertion and scan the lines contained in the file.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:n2c}>>=
  func scan(r io.Reader, args ...interface{}) {
	  dec := args[0].(bool)
	  dict := args[1].(map[string]string)
	  sc := fasta.NewScanner(r)
	  //<<Scan lines, Ch.~\ref{ch:n2c}>>
  }
#+end_src
#+begin_src latex
  We import \ty{io} and \ty{fasta}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "io"
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_src latex
  We scan the lines and deal with each one. After the end of the file we
  flush the scanner and deal with the ``line'' returned.
#+end_src
#+begin_src go <<Scan lines, Ch.~\ref{ch:n2c}>>=
  for sc.ScanLine() {
	  line := sc.Line()
	  //<<Deal with line, Ch.~\ref{ch:n2c}>>
  }
  line := sc.Flush()
  //<<Deal with line, Ch.~\ref{ch:n2c}>>
#+end_src
#+begin_src latex
  A line is either decoded or encoded, which we both delegate to
  function calls.
#+end_src
#+begin_src go <<Deal with line, Ch.~\ref{ch:n2c}>>=
  if dec {
	  decode(line, dict)
  } else {
	  encode(line, dict)
  }
#+end_src
#+begin_src latex
  Inside decode we first check there is some data to process. This is
  either a header or decode a line.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:n2c}>>=
  func decode(data []byte, dict map[string]string) {
	  if len(data) == 0 { return }
	  if data[0] == '>' {
		  //<<Decode header, Ch.~\ref{ch:n2c}>>
	  } else {
		  //<<Decode data, Ch.~\ref{ch:n2c}>>
	  }
  }
#+end_src
#+begin_src latex
  We decode the header by printing it with a note about the
  transformation appended.
#+end_src
#+begin_src go <<Decode header, Ch.~\ref{ch:n2c}>>=
  h := string(data) + " - num2char -d"
  fmt.Printf("%s\n", h)
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "fmt"
#+end_src
#+begin_src latex
  A line to be decoded consists of characters that we convert to
  strings representing numbers. We print these strings delimited by
  blanks. first construct a slice of number strings, which we then
  convert. We bail if we cannot look up an input string and close the
  line with a newline.
#+end_src
#+begin_src go <<Decode data, Ch.~\ref{ch:n2c}>>=
  l := len(data) - 1
  for i, c := range data {
	  k := string(c)
	  v, ok := dict[k]
	  if !ok { log.Fatalf("cannot decode %s", k) }
	  fmt.Printf("%s", v)
	  if i < l { fmt.Printf(" ") }
  }
  fmt.Printf("\n")
#+end_src
#+begin_src latex
  We import \ty{log}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "log"
#+end_src
#+begin_src latex
  Inside \ty{encode} we again first check we have data to process. Then
  we encode either a header or data.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:n2c}>>=
  func encode(data []byte, dict map[string]string) {
	  if len(data) == 0 { return }
	  if data[0] == '>' {
		  //<<Encode header, Ch.~\ref{ch:n2c}>>
	  } else {
		  //<<Encode data, Ch.~\ref{ch:n2c}>>
	  }
  }
#+end_src
#+begin_src latex
  We encode a header by printing it with a note of the transformation
  appended.
#+end_src
#+begin_src go <<Encode header, Ch.~\ref{ch:n2c}>>=
  h := string(data) + " - num2char"
  fmt.Printf("%s\n", h)
#+end_src
#+begin_src latex
  Data to be encoded consists of strings that we convert to
  characters. The strings make up fields in the byte slice holding the
  data. We extract these fields, iterate over them, and print the
  corresponding characters. As before, we mark the transformation at the
  end of its header and end the line with a newline.
#+end_src
#+begin_src go <<Encode data, Ch.~\ref{ch:n2c}>>=
  bs := bytes.Fields(data)
  for _, n := range bs {
	  v , ok := dict[string(n)]
	  if !ok { log.Fatalf("cannot encode %s", string(n)) }
	  fmt.Printf("%s", v)
  }
  fmt.Printf("\n")
#+end_src
#+begin_src latex
  We import \ty{bytes}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:n2c}>>=
  "bytes"
#+end_src
#+begin_src latex
  We've finished writing \ty{num2char}, time to test it.
  \section*{Testing}
  The outline of our testing code contains hooks for imports and the
  testing logic.
#+end_src
#+begin_src go <<num2char_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:n2c}>>
  )

  func TestNum2char(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:n2c}>>
  }
#+end_src
#+begin_src latex
  We construct the tests and run them.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:n2c}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Ch.~\ref{ch:n2c}>>
  for i, test := range tests {
	  //<<Run test, Ch.~\ref{ch:n2c}>>
  }
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:n2c}>>=
  "os/exec"
#+end_src
#+begin_src latex
  We construct two tests, one to run \ty{num2char} in default encoding
  mode, one to run it in decoding mode. The input to the first test is
  some small output generated with \ty{mtf}, the input to the second
  test is the expected result of the first.
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:n2c}>>=
  test := exec.Command("./num2char", "mtf.fasta")
  tests = append(tests, test)
  test = exec.Command("./num2char", "-d", "r1.txt")
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We store the result we get with the result we want, which is stored in
  files \ty{r1.txt} and \ty{r2.txt}.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:n2c}>>=
  get, err := test.Output()
  if err != nil { t.Errorf("couldn't run %s", test) }
  f := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := ioutil.ReadFile(f)
  if err != nil { t.Errorf("couldn't open %q", f) }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:%s\n", get, want)
  }
#+end_src
#+begin_src latex
  We import \ty{strconv}, \ty{ioutil}, and \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:n2c}>>=
  "strconv"
  "io/ioutil"
  "bytes"
#+end_src
