#+begin_src latex
  \section*{Introduction}
  The program \texttt{al} aligns two sequences, a query, $q$, and a
  subject, $s$. It computes a global alignment by default
  (Figure~\ref{fig:alTypes}A), but the user can request a global
  alignment (Figure~\ref{fig:alTypes}B) or an overlap
  (Figure~\ref{fig:alTypes}C) alignment.
  \begin{figure}
    \begin{center}
      \begin{psmatrix}[rowsep=0.2cm]
	\textbf{A} & \textbf{B} & \textbf{C}\\
	\input{gal} & \input{lal} & \input{oal}
      \end{psmatrix}
    \end{center}
    \caption{The three types of alignment, global (\textbf{A}), local
      (\textbf{B}), and overlap (\textbf{C}). Homology in
      black.}\label{fig:alTypes}
  \end{figure}
  \ty{al} can align DNA sequences using match/mismatch scores, or
  protein sequences using substitution matrices. It uses an affine gap
  score, where a gap of length $l$ has score
  \[
  g(l)=g_{\rm o}+g_{\rm e}(l-1),
  \]
  and $g_{\rm o}$ is the gap opening score, $g_{\rm e}$ the gap
  extension score. The program is based on the \ty{pal}
  package\footnote{\ty{github.com/evolbioinf/pal}, where the algorithms
    are described in detail.
  \section*{Implementation}
  The program outline contains hooks for imports, variables, functions,
  and the logic of the main function.
#+end_src
#+begin_src go <<al.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:al}>>
  )
  //<<Variables, Ch.~\ref{ch:al}>>
  //<<Functions, Ch.~\ref{ch:al}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:al}>>
  }
#+end_src
#+begin_src latex
  In the main function we set the usage, parse the options, and compute
  one or more alignments.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:al}>>=
  //<<Set usage, Ch.~\ref{ch:al}>>
  //<<Parse options, Ch.~\ref{ch:al}>>
  //<<Compute alignments, Ch.~\ref{ch:al}>>
#+end_src
#+begin_src latex
  The usage consists of the usage proper, an explanation of the
  program's purpose, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:al}>>=
  u := "al [-h] [options] query.fasta [subject files]"
  p := "Align two sequences."
  e := "al query.fasta subject.fasta"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \texttt{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the standard \emph{version} option, we declare options for
  the algorithm used, the scoring of pairs of residues and gaps, the
  number of local alignments, and the line length in the printout.
#+end_src
#+begin_src go <<Variables, Ch.~\ref{ch:al}>>=
  var optV = flag.Bool("v", false, "print version & " +
	  "program information")
  var optL = flag.Bool("l", false, "local (default global)")
  var optO = flag.Bool("o", false, "overlap (default global)")
  var optI = flag.Float64("i", -3, "mismatch")
  var optA = flag.Float64("a",  1, "match")
  var optM = flag.String("m", "", "file containing score matrix")
  var optP = flag.Float64("p", -5, "gap opening")
  var optE = flag.Float64("e", -2, "gap extension")
  var optN = flag.Int("n", 1, "number of local alignments")
  var optLL = flag.Int("L", fasta.DefaultLineLength, "line length")
#+end_src
#+begin_src latex
  We import \texttt{flag} and \texttt{fasta}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "flag"
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_src latex
  When parsing the options, we check for version printing, then get the
  files for the query, the subject, and the score matrix.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:al}>>=
  flag.Parse()
  if *optV {
	  util.PrintInfo("al")
  }
  //<<Get query and subject files, Ch.~\ref{ch:al}>>
  //<<Get score matrix, Ch.~\ref{ch:al}>>
#+end_src
#+begin_src latex
  We import \texttt{util}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "github.com/evolbioinf/biobox/util"
#+end_src
#+begin_src latex
  When accessing the input files, we make sure that the user has
  actually given a query file.
#+end_src
#+begin_src go <<Get query and subject files, Ch.~\ref{ch:al}>>=
  files := flag.Args()
  if len(files) < 1 {
	  fmt.Fprintf(os.Stderr, "please give the name " +
		  "of a query file\n")
	  os.Exit(0)
  }
  query := files[0]
  subject := files[1:]
#+end_src
#+begin_src latex
  Import \texttt{fmt} and \texttt{os}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "fmt"
  "os"
#+end_src
#+begin_src latex
  The score matrix is either constructed from the match and mismatch
  scores, or read from a file.
#+end_src
#+begin_src go <<Get score matrix, Ch.~\ref{ch:al}>>=
  var mat *pal.ScoreMatrix
  if *optM == "" {
	  mat = pal.NewScoreMatrix(*optA, *optI)
  } else {
	  f, err := os.Open(*optM)
	  if err != nil {
		  log.Fatalf("couldn't open score matrix %q\n",
			  *optM)
	  } 
	  mat = pal.ReadScoreMatrix(f)
	  f.Close()
  }
#+end_src
#+begin_src latex
  We import \ty{pal}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "github.com/evolbioinf/pal"
#+end_src
#+begin_src latex
  When computing the alignments, we iterate over the query sequences and
  pass each one to the \texttt{scan} function, together with the names
  of the subject files and the substitution matrix.
#+end_src
#+begin_src go <<Compute alignments, Ch.~\ref{ch:al}>>=
  qf, err := os.Open(query)
  if err != nil {
	  log.Fatalf("couldn't open %q\n", query)
  }
  sc := fasta.NewScanner(qf)
  for sc.ScanSequence() {
	  q := sc.Sequence()
	  clio.ParseFiles(subject, scan, q, mat)
  }
#+end_src
#+begin_src latex 
  We import \texttt{log}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "log"
#+end_src
#+begin_src latex
  In the function \texttt{scan}, the arguments just passed are retrieved
  again and we iterate over the subject sequences.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:al}>>=
  func scan(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Ch.~\ref{ch:al}>>
	  //<<Iterate over subject sequences, Ch.~\ref{ch:al}>>
  }
#+end_src
#+begin_src latex
  We import \texttt{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "io"
#+end_src
#+begin_src latex
  The arguments are retrieved via type assertions, or as global
  variables.
#+end_src
#+begin_src go <<Retrieve arguments, Ch.~\ref{ch:al}>>=
  q := args[0].(*fasta.Sequence)
  mat := args[1].(*pal.ScoreMatrix)
  isLocal := *optL
  isOverlap := *optO
  gapO := *optP
  gapE := *optE
  numAl := *optN
  ll := *optLL
#+end_src
#+begin_src latex
  Then we iterate across the subject sequences and align each one with
  the query.
#+end_src
#+begin_src go <<Iterate over subject sequences, Ch.~\ref{ch:al}>>=
  sc := fasta.NewScanner(r)
  for sc.ScanSequence() {
	  s := sc.Sequence()
	  //<<Align query and subject, Ch.~\ref{ch:al}>>
  }
#+end_src
#+begin_src latex
  We calculate either a local, an overlap, or a global alignment.
#+end_src
#+begin_src go <<Align query and subject, Ch.~\ref{ch:al}>>=
  if isLocal {
	  //<<Calculate local alignment, Ch.~\ref{ch:al}>>
  } else if isOverlap {
	  //<<Calculate overlap alignment, Ch.~\ref{ch:al}>>
  } else {
	  //<<Calculate global alignment, Ch.~\ref{ch:al}>>
  }
#+end_src
#+begin_src latex 
  We initialize a local alignment and set its line length. Then we align
  the requested number of times and print the alignment.
#+end_src
#+begin_src go <<Calculate local alignment, Ch.~\ref{ch:al}>>=
  al := pal.NewLocalAlignment(q, s, mat, gapO, gapE)
  al.SetLineLength(ll)
  for i := 0; i < numAl && al.Align(); i++ {
	  fmt.Println(al)
  }
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:al}>>=
  "fmt"
#+end_src
#+begin_src latex
  Similarly, we initialize an overlap alignment,  set its line length,
  carry out the actual alignment, and print it.
#+end_src
#+begin_src go <<Calculate overlap alignment, Ch.~\ref{ch:al}>>=
  al := pal.NewOverlapAlignment(q, s, mat, gapO, gapE)
  al.SetLineLength(ll)
  al.Align()
  fmt.Println(al)
#+end_src
#+begin_src latex
  Finally, we initialize the default global alignment, set its line
  length, carry out the alignment, and print it.
#+end_src
#+begin_src go <<Calculate global alignment, Ch.~\ref{ch:al}>>=
  al := pal.NewGlobalAlignment(q, s, mat, gapO, gapE)
  al.SetLineLength(ll)
  al.Align()
  fmt.Println(al)
#+end_src
#+begin_src latex
  The implementation of \texttt{al} is finished, time to test it.
  \section*{Testing}
  The testing outline contains hooks for imports and the testing logic.
#+end_src
#+begin_src go <<al_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:al}>>
  )

  func TestAl(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:al}>>
  }
#+end_src
#+begin_src latex
  We go through the alignment types, beginning with global. First two
  short peptides are aligned and we compare what we get with what we
  want in \texttt{res1.txt}.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:al}>>=
  cmd := exec.Command("./al", "-m", "BLOSUM62", "s1.fasta",
	  "s2.fasta")
  get, err := cmd.Output()
  if err != nil { t.Errorf("couldn't run %q\n", cmd) }
  want, err := ioutil.ReadFile("res1.txt")
  if err != nil { t.Errorf("couldn't open res1.txt\n") }
  if !bytes.Equal(get, want) { 
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get) 
  }
#+end_src
#+begin_src latex
  We import \texttt{exec}, \texttt{ioutil}, and \texttt{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:al}>>=
  "os/exec"
  "io/ioutil"
  "bytes"
#+end_src
#+begin_src latex
  In the next test, the alcohol dehydrogenase loci of two
  \emph{Drosophila} species, \emph{D. melanogaster} and
  \emph{D. guanche}, are aligned. The two sequences are 4.8 kb and 4.4
  kb long, which results in a fairly substantial computation, but
  \texttt{al} is reasonably quick. The expected result is in
  \texttt{res2.txt}.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:al}>>=
  cmd = exec.Command("./al", "dmAdhAdhdup.fasta",
	  "dgAdhAdhdup.fasta")
  get, err = cmd.Output()
  if err != nil { t.Errorf("couldn't run %q\n", cmd) }
  want, err = ioutil.ReadFile("res2.txt")
  if err != nil { t.Errorf("couldn't open res2.txt") }
  if !bytes.Equal(get, want) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src latex
  We align a pair of artificial overlapping sequences using overlap
  alignment, \texttt{o1.fasta} and \texttt{o2.fasta}. The result we want
  is stored in \texttt{res3.txt}.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:al}>>=
  cmd = exec.Command("./al", "-o", "o1.fasta", "o2.fasta")
  get, err = cmd.Output()
  if err != nil { t.Errorf("couldn't run %q\n", cmd) }
  want, err = ioutil.ReadFile("res3.txt")
  if err != nil { t.Errorf("couldn't open res3.txt") }
  if !bytes.Equal(get, want) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src latex
  As a last test, we compute the best local alignment; this time we want
  \texttt{res4.txt}.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:al}>>=
  cmd = exec.Command("./al", "-l", "dmAdhAdhdup.fasta",
	  "dgAdhAdhdup.fasta")
  get, err = cmd.Output()
  if err != nil { t.Errorf("couldn't run %q\n", cmd) }
  want, err = ioutil.ReadFile("res4.txt")
  if err != nil { t.Errorf("couldn't open res4.txt") }
  if !bytes.Equal(get, want) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
